{"version":3,"file":"solid.js","names":["value","children","e","i","sources","tagName","document","marker","toPropertyName","html","i","delegateEvents","tag","children","childOptions","children","params","source","options","matches","Root","child","cache","intent","inPreloadFn","dataOnly","res"],"sources":["../node_modules/solid-js/dist/solid.js","../node_modules/solid-js/web/dist/web.js","../node_modules/solid-js/html/dist/html.js","../node_modules/@solidjs/router/dist/index.js","solid.ts"],"sourcesContent":["let taskIdCounter = 1,\n  isCallbackScheduled = false,\n  isPerformingWork = false,\n  taskQueue = [],\n  currentTask = null,\n  shouldYieldToHost = null,\n  yieldInterval = 5,\n  deadline = 0,\n  maxYieldInterval = 300,\n  scheduleCallback = null,\n  scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n    port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = (n + m) >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;\n      else if (cmp < 0) n = k - 1;\n      else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n    timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {\n  context: undefined,\n  registry: undefined,\n  effects: undefined,\n  done: false,\n  getContextId() {\n    return getContextId(this.context.count);\n  },\n  getNextContextId() {\n    return getContextId(this.context.count++);\n  }\n};\nfunction getContextId(count) {\n  const num = String(count),\n    len = num.length - 1;\n  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : \"\") + num;\n}\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return {\n    ...sharedConfig.context,\n    id: sharedConfig.getNextContextId(),\n    count: 0\n  };\n}\n\nconst IS_DEV = false;\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst SUPPORTS_PROXY = typeof Proxy === \"function\";\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    current = detachedOwner === undefined ? owner : detachedOwner,\n    root = unowned\n      ? UNOWNED\n      : {\n          owned: null,\n          cleanups: null,\n          context: current ? current.context : null,\n          owner: current\n        },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);\n      else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);\n  else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  if (!options || !options.render) c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(\n      () => {\n        fn ? fn() : untrack(onInvalidate);\n        fn = undefined;\n      },\n      undefined,\n      false,\n      0\n    ),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if (typeof pFetcher === \"function\") {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  } else {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  }\n  let pr = null,\n    initP = NO_INIT,\n    id = null,\n    loadedUnderTransition = false,\n    scheduled = false,\n    resolved = \"initialValue\" in options,\n    dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n    [value, setValue] = (options.storage || createSignal)(options.initialValue),\n    [error, setError] = createSignal(undefined),\n    [track, trigger] = createSignal(undefined, {\n      equals: false\n    }),\n    [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = sharedConfig.getNextContextId();\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;\n    else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      key !== undefined && (resolved = true);\n      if ((p === initP || v === initP) && options.onHydrated)\n        queueMicrotask(() =>\n          options.onHydrated(key, {\n            value: v\n          })\n        );\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === undefined) setValue(() => v);\n      setState(err !== undefined ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && useContext(SuspenseContext),\n      v = value(),\n      err = error();\n    if (err !== undefined && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);\n          else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p =\n      initP !== NO_INIT\n        ? initP\n        : untrack(() =>\n            fetcher(lookup, {\n              value: value(),\n              refetching\n            })\n          );\n    if (!isPromise(p)) {\n      loadEnd(pr, p, undefined, lookup);\n      return p;\n    }\n    pr = p;\n    if (\"value\" in p) {\n      if (p.status === \"success\") loadEnd(pr, p.value, undefined, lookup);\n      else loadEnd(pr, undefined, castError(p.value), lookup);\n      return p;\n    }\n    scheduled = true;\n    queueMicrotask(() => (scheduled = false));\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(\n      v => loadEnd(p, v, undefined, lookup),\n      e => loadEnd(p, undefined, castError(e), lookup)\n    );\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));\n  else load(false);\n  return [\n    read,\n    {\n      refetch: load,\n      mutate: setValue\n    }\n  ];\n}\nfunction createDeferred(source, options) {\n  let t,\n    timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(\n    () => {\n      if (!t || !t.fn)\n        t = requestCallback(\n          () => setDeferred(() => node.value),\n          timeout !== undefined\n            ? {\n                timeout\n              }\n            : undefined\n        );\n      return source();\n    },\n    undefined,\n    true\n  );\n  const [deferred, setDeferred] = createSignal(\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    options\n  );\n  updateComputation(node);\n  setDeferred(() =>\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n  );\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(\n    p => {\n      const v = source();\n      for (const [key, val] of subs.entries())\n        if (fn(key, v) !== fn(key, p)) {\n          for (const c of val.values()) {\n            c.state = STALE;\n            if (c.pure) Updates.push(c);\n            else Effects.push(c);\n          }\n        }\n      return v;\n    },\n    undefined,\n    true,\n    STALE\n  );\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if ((l = subs.get(key))) l.add(listener);\n      else subs.set(key, (l = new Set([listener])));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(\n      key,\n      Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value\n    );\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (!ExternalSourceConfig && Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return prevValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null);\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction catchError(fn, handler) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  Owner = createComputation(undefined, undefined, true);\n  Owner.context = {\n    ...Owner.context,\n    [ERROR]: [handler]\n  };\n  if (Transition && Transition.running) Transition.sources.add(Owner);\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = Owner.owner;\n  }\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t =\n        Transition ||\n        (Transition = {\n          sources: new Set(),\n          effects: [],\n          promises: new Set(),\n          disposed: new Set(),\n          queue: new Set(),\n          running: true\n        });\n      t.done || (t.done = new Promise(res => (t.resolve = res)));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nconst [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let value;\n  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined\n    ? value\n    : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext());\n}\nfunction enableExternalSource(factory, untrack = fn => fn()) {\n  if (ExternalSourceConfig) {\n    const { factory: oldFactory, untrack: oldUntrack } = ExternalSourceConfig;\n    ExternalSourceConfig = {\n      factory: (fn, trigger) => {\n        const oldSource = oldFactory(fn, trigger);\n        const source = factory(x => oldSource.track(x), trigger);\n        return {\n          track: x => source.track(x),\n          dispose() {\n            source.dispose();\n            oldSource.dispose();\n          }\n        };\n      },\n      untrack: fn => oldUntrack(() => untrack(fn))\n    };\n  } else {\n    ExternalSourceConfig = {\n      factory,\n      untrack\n    };\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (runningTransition ? this.tState : this.state)) {\n    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current =\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || (!isComp && Transition.sources.has(node))) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);\n            else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;\n          else o.tState = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (IS_DEV);\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(\n    node,\n    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,\n    time\n  );\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner,\n    listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      if (Transition && Transition.running) {\n        node.tState = STALE;\n        node.tOwned && node.tOwned.forEach(cleanNode);\n        node.tOwned = undefined;\n      } else {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null);\n  else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];\n      else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];\n      else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceConfig && c.fn) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if ((runningTransition ? node.tState : node.state) === 0) return;\n  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (runningTransition ? node.tState : node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n        prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if ((runningTransition ? node.tState : node.state) === STALE) {\n      updateComputation(node);\n    } else if ((runningTransition ? node.tState : node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);\n    else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);\n    else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) {\n    if (sharedConfig.count) {\n      sharedConfig.effects || (sharedConfig.effects = []);\n      sharedConfig.effects.push(...queue.slice(0, userLength));\n      return;\n    }\n    setHydrateContext();\n  }\n  if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {\n    queue = [...sharedConfig.effects, ...queue];\n    userLength += sharedConfig.effects.length;\n    delete sharedConfig.effects;\n  }\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;\n  else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = runningTransition ? source.tState : source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))\n          runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (runningTransition ? !o.tState : !o.state) {\n      if (runningTransition) o.tState = PENDING;\n      else o.state = PENDING;\n      if (o.pure) Updates.push(o);\n      else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (node.tOwned) {\n    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n    delete node.tOwned;\n  }\n  if (Transition && Transition.running && node.pure) {\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;\n  else node.state = 0;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction runErrors(err, fns, owner) {\n  try {\n    for (const f of fns) f(err);\n  } catch (e) {\n    handleError(e, (owner && owner.owner) || null);\n  }\n}\nfunction handleError(err, owner = Owner) {\n  const fns = ERROR && owner && owner.context && owner.context[ERROR];\n  const error = castError(err);\n  if (!fns) throw error;\n  if (Effects)\n    Effects.push({\n      fn() {\n        runErrors(error, fns, owner);\n      },\n      state: STALE\n    });\n  else runErrors(error, fns, owner);\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(\n      () =>\n        (res = untrack(() => {\n          Owner.context = {\n            ...Owner.context,\n            [id]: props.value\n          };\n          return children(() => props.children);\n        })),\n      undefined\n    );\n    return res;\n  };\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null);\n  else if (Owner.context === null || !Owner.context[ERROR]) {\n    Owner.context = {\n      ...Owner.context,\n      [ERROR]: [fn]\n    };\n    mutateContext(Owner, ERROR, [fn]);\n  } else Owner.context[ERROR].push(fn);\n}\nfunction mutateContext(o, key, value) {\n  if (o.owned) {\n    for (let i = 0; i < o.owned.length; i++) {\n      if (o.owned[i].context === o.context) mutateContext(o.owned[i], key, value);\n      if (!o.owned[i].context) {\n        o.owned[i].context = o.context;\n        mutateContext(o.owned[i], key, value);\n      } else if (!o.owned[i].context[key]) {\n        o.owned[i].context[key] = value;\n        mutateContext(o.owned[i], key, value);\n      }\n    }\n  }\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler =\n        typeof observer === \"function\" ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer, initalValue = undefined) {\n  const [s, set] = createSignal(initalValue, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => (\"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub()));\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      newLen = newItems.length,\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (\n          start = 0, end = Math.min(len, newLen);\n          start < end && items[start] === newItems[start];\n          start++\n        );\n        for (\n          end = len - 1, newEnd = newLen - 1;\n          end >= start && newEnd >= start && items[end] === newItems[newEnd];\n          end--, newEnd--\n        ) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, (len = newLen));\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [],\n      newLen = newItems.length;\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newLen; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newLen;\n      items = newItems.slice(0);\n      return (mapped = mapped.slice(0, len));\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction resolveSources() {\n  for (let i = 0, length = this.length; i < length; ++i) {\n    const v = this[i]();\n    if (v !== undefined) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || (!!s && $PROXY in s);\n    sources[i] = typeof s === \"function\" ? ((proxy = true), createMemo(s)) : s;\n  }\n  if (SUPPORTS_PROXY && proxy) {\n    return new Proxy(\n      {\n        get(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            const v = resolveSource(sources[i])[property];\n            if (v !== undefined) return v;\n          }\n        },\n        has(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            if (property in resolveSource(sources[i])) return true;\n          }\n          return false;\n        },\n        keys() {\n          const keys = [];\n          for (let i = 0; i < sources.length; i++)\n            keys.push(...Object.keys(resolveSource(sources[i])));\n          return [...new Set(keys)];\n        }\n      },\n      propTraps\n    );\n  }\n  const sourcesMap = {};\n  const defined = Object.create(null);\n  for (let i = sources.length - 1; i >= 0; i--) {\n    const source = sources[i];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i = sourceKeys.length - 1; i >= 0; i--) {\n      const key = sourceKeys[i];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get\n          ? {\n              enumerable: true,\n              configurable: true,\n              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))\n            }\n          : desc.value !== undefined\n          ? desc\n          : undefined;\n      } else {\n        const sources = sourcesMap[key];\n        if (sources) {\n          if (desc.get) sources.push(desc.get.bind(source));\n          else if (desc.value !== undefined) sources.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i = definedKeys.length - 1; i >= 0; i--) {\n    const key = definedKeys[i],\n      desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : undefined;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if (SUPPORTS_PROXY && $PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map(k => {\n      return new Proxy(\n        {\n          get(property) {\n            return k.includes(property) ? props[property] : undefined;\n          },\n          has(property) {\n            return k.includes(property) && property in props;\n          },\n          keys() {\n            return k.filter(property => property in props);\n          }\n        },\n        propTraps\n      );\n    });\n    res.push(\n      new Proxy(\n        {\n          get(property) {\n            return blocked.has(property) ? undefined : props[property];\n          },\n          has(property) {\n            return blocked.has(property) ? false : property in props;\n          },\n          keys() {\n            return Object.keys(props).filter(k => !blocked.has(k));\n          }\n        },\n        propTraps\n      )\n    );\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc =\n      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc\n          ? (objects[objectIndex][propName] = desc.value)\n          : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc\n        ? (otherObject[propName] = desc.value)\n        : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      sharedConfig.count || (sharedConfig.count = 0);\n      sharedConfig.count++;\n      (p || (p = fn())).then(mod => {\n        !sharedConfig.done && setHydrateContext(ctx);\n        sharedConfig.count--;\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    }\n    let Comp;\n    return createMemo(() =>\n      (Comp = comp())\n        ? untrack(() => {\n            if (IS_DEV);\n            if (!ctx || sharedConfig.done) return Comp(props);\n            const c = sharedConfig.context;\n            setHydrateContext(ctx);\n            const r = Comp(props);\n            setHydrateContext(c);\n            return r;\n          })\n        : \"\"\n    );\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => (comp = () => mod.default)), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? sharedConfig.getNextContextId() : `cl-${counter++}`;\n}\n\nconst narrowedError = name => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const conditionValue = createMemo(() => props.when, undefined, undefined);\n  const condition = keyed\n    ? conditionValue\n    : createMemo(conditionValue, undefined, {\n        equals: (a, b) => !a === !b\n      });\n  return createMemo(\n    () => {\n      const c = condition();\n      if (c) {\n        const child = props.children;\n        const fn = typeof child === \"function\" && child.length > 0;\n        return fn\n          ? untrack(() =>\n              child(\n                keyed\n                  ? c\n                  : () => {\n                      if (!untrack(condition)) throw narrowedError(\"Show\");\n                      return conditionValue();\n                    }\n              )\n            )\n          : child;\n      }\n      return props.fallback;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Switch(props) {\n  const chs = children(() => props.children);\n  const switchFunc = createMemo(() => {\n    const ch = chs();\n    const mps = Array.isArray(ch) ? ch : [ch];\n    let func = () => undefined;\n    for (let i = 0; i < mps.length; i++) {\n      const index = i;\n      const mp = mps[i];\n      const prevFunc = func;\n      const conditionValue = createMemo(\n        () => (prevFunc() ? undefined : mp.when),\n        undefined,\n        undefined\n      );\n      const condition = mp.keyed\n        ? conditionValue\n        : createMemo(conditionValue, undefined, {\n            equals: (a, b) => !a === !b\n          });\n      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : undefined);\n    }\n    return func;\n  });\n  return createMemo(\n    () => {\n      const sel = switchFunc()();\n      if (!sel) return props.fallback;\n      const [index, conditionValue, mp] = sel;\n      const child = mp.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn\n        ? untrack(() =>\n            child(\n              mp.keyed\n                ? conditionValue()\n                : () => {\n                    if (untrack(switchFunc)()?.[0] !== index) throw narrowedError(\"Match\");\n                    return conditionValue();\n                  }\n            )\n          )\n        : child;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  if (sharedConfig.context && sharedConfig.load)\n    err = sharedConfig.load(sharedConfig.getContextId());\n  const [errored, setErrored] = createSignal(err, undefined);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(\n    () => {\n      let e;\n      if ((e = errored())) {\n        const f = props.fallback;\n        return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n      }\n      return catchError(() => props.children, setErrored);\n    },\n    undefined,\n    undefined\n  );\n}\n\nconst suspenseListEquals = (a, b) =>\n  a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = /* #__PURE__ */ createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n      inFallback: false\n    })),\n    show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(\n    prev => {\n      const reveal = props.revealOrder,\n        tail = props.tail,\n        { showContent = true, showFallback = true } = show ? show() : {},\n        reg = registry(),\n        reverse = reveal === \"backwards\";\n      if (reveal === \"together\") {\n        const all = reg.every(inFallback => !inFallback());\n        const res = reg.map(() => ({\n          showContent: all && showContent,\n          showFallback\n        }));\n        res.inFallback = !all;\n        return res;\n      }\n      let stop = false;\n      let inFallback = prev.inFallback;\n      const res = [];\n      for (let i = 0, len = reg.length; i < len; i++) {\n        const n = reverse ? len - i - 1 : i,\n          s = reg[n]();\n        if (!stop && !s) {\n          res[n] = {\n            showContent,\n            showFallback\n          };\n        } else {\n          const next = !stop;\n          if (next) inFallback = true;\n          res[n] = {\n            showContent: next,\n            showFallback: !tail || (next && tail === \"collapsed\") ? showFallback : false\n          };\n          stop = true;\n        }\n      }\n      if (!stop) inFallback = false;\n      res.inFallback = inFallback;\n      return res;\n    },\n    {\n      inFallback: false\n    }\n  );\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n    show,\n    ctx,\n    p,\n    flicker,\n    error;\n  const [inFallback, setFallback] = createSignal(false),\n    SuspenseContext = getSuspenseContext(),\n    store = {\n      increment: () => {\n        if (++counter === 1) setFallback(true);\n      },\n      decrement: () => {\n        if (--counter === 0) setFallback(false);\n      },\n      inFallback,\n      effects: [],\n      resolved: false\n    },\n    owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.getContextId();\n    let ref = sharedConfig.load(key);\n    if (ref) {\n      if (typeof ref !== \"object\" || ref.status !== \"success\") p = ref;\n      else sharedConfig.gather(key);\n    }\n    if (p && p !== \"$$f\") {\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(\n        () => {\n          if (sharedConfig.done) return set();\n          sharedConfig.gather(key);\n          setHydrateContext(ctx);\n          set();\n          setHydrateContext();\n        },\n        err => {\n          error = err;\n          set();\n        }\n      );\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return (flicker = undefined);\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n            { showContent = true, showFallback = true } = show ? show() : {};\n          if ((!inFallback || (p && p !== \"$$f\")) && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"F\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nconst DEV = undefined;\n\nexport {\n  $DEVCOMP,\n  $PROXY,\n  $TRACK,\n  DEV,\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  Show,\n  Suspense,\n  SuspenseList,\n  Switch,\n  batch,\n  cancelCallback,\n  catchError,\n  children,\n  createComponent,\n  createComputed,\n  createContext,\n  createDeferred,\n  createEffect,\n  createMemo,\n  createReaction,\n  createRenderEffect,\n  createResource,\n  createRoot,\n  createSelector,\n  createSignal,\n  createUniqueId,\n  enableExternalSource,\n  enableHydration,\n  enableScheduling,\n  equalFn,\n  from,\n  getListener,\n  getOwner,\n  indexArray,\n  lazy,\n  mapArray,\n  mergeProps,\n  observable,\n  on,\n  onCleanup,\n  onError,\n  onMount,\n  requestCallback,\n  resetErrorBoundaries,\n  runWithOwner,\n  sharedConfig,\n  splitProps,\n  startTransition,\n  untrack,\n  useContext,\n  useTransition\n};\n","import {\n  createRoot,\n  createRenderEffect,\n  untrack,\n  sharedConfig,\n  enableHydration,\n  getOwner,\n  createEffect,\n  runWithOwner,\n  createMemo,\n  createSignal,\n  onCleanup,\n  splitProps\n} from \"solid-js\";\nexport {\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  Show,\n  Suspense,\n  SuspenseList,\n  Switch,\n  createComponent,\n  createRenderEffect as effect,\n  getOwner,\n  createMemo as memo,\n  mergeProps,\n  untrack\n} from \"solid-js\";\n\nconst booleans = [\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"indeterminate\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"seamless\",\n  \"selected\"\n];\nconst Properties = /*#__PURE__*/ new Set([\n  \"className\",\n  \"value\",\n  \"readOnly\",\n  \"formNoValidate\",\n  \"isMap\",\n  \"noModule\",\n  \"playsInline\",\n  ...booleans\n]);\nconst ChildProperties = /*#__PURE__*/ new Set([\n  \"innerHTML\",\n  \"textContent\",\n  \"innerText\",\n  \"children\"\n]);\nconst Aliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /*#__PURE__*/ Object.assign(Object.create(null), {\n  class: \"className\",\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a = PropAliases[prop];\n  return typeof a === \"object\" ? (a[tagName] ? a[\"$\"] : undefined) : a;\n}\nconst DelegatedEvents = /*#__PURE__*/ new Set([\n  \"beforeinput\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"focusin\",\n  \"focusout\",\n  \"input\",\n  \"keydown\",\n  \"keyup\",\n  \"mousedown\",\n  \"mousemove\",\n  \"mouseout\",\n  \"mouseover\",\n  \"mouseup\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerout\",\n  \"pointerover\",\n  \"pointerup\",\n  \"touchend\",\n  \"touchmove\",\n  \"touchstart\"\n]);\nconst SVGElements = /*#__PURE__*/ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/ new Set([\n  \"html\",\n  \"base\",\n  \"head\",\n  \"link\",\n  \"meta\",\n  \"style\",\n  \"title\",\n  \"body\",\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"footer\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"section\",\n  \"body\",\n  \"blockquote\",\n  \"dd\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"figcaption\",\n  \"figure\",\n  \"hr\",\n  \"li\",\n  \"ol\",\n  \"p\",\n  \"pre\",\n  \"ul\",\n  \"a\",\n  \"abbr\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"br\",\n  \"cite\",\n  \"code\",\n  \"data\",\n  \"dfn\",\n  \"em\",\n  \"i\",\n  \"kbd\",\n  \"mark\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"small\",\n  \"span\",\n  \"strong\",\n  \"sub\",\n  \"sup\",\n  \"time\",\n  \"u\",\n  \"var\",\n  \"wbr\",\n  \"area\",\n  \"audio\",\n  \"img\",\n  \"map\",\n  \"track\",\n  \"video\",\n  \"embed\",\n  \"iframe\",\n  \"object\",\n  \"param\",\n  \"picture\",\n  \"portal\",\n  \"source\",\n  \"svg\",\n  \"math\",\n  \"canvas\",\n  \"noscript\",\n  \"script\",\n  \"del\",\n  \"ins\",\n  \"caption\",\n  \"col\",\n  \"colgroup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"tr\",\n  \"button\",\n  \"datalist\",\n  \"fieldset\",\n  \"form\",\n  \"input\",\n  \"label\",\n  \"legend\",\n  \"meter\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"progress\",\n  \"select\",\n  \"textarea\",\n  \"details\",\n  \"dialog\",\n  \"menu\",\n  \"summary\",\n  \"details\",\n  \"slot\",\n  \"template\",\n  \"acronym\",\n  \"applet\",\n  \"basefont\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"center\",\n  \"content\",\n  \"dir\",\n  \"font\",\n  \"frame\",\n  \"frameset\",\n  \"hgroup\",\n  \"image\",\n  \"keygen\",\n  \"marquee\",\n  \"menuitem\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"plaintext\",\n  \"rb\",\n  \"rtc\",\n  \"shadow\",\n  \"spacer\",\n  \"strike\",\n  \"tt\",\n  \"xmp\",\n  \"a\",\n  \"abbr\",\n  \"acronym\",\n  \"address\",\n  \"applet\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"basefont\",\n  \"bdi\",\n  \"bdo\",\n  \"bgsound\",\n  \"big\",\n  \"blink\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"center\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"content\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"font\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"image\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"marquee\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"nobr\",\n  \"noembed\",\n  \"noframes\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"plaintext\",\n  \"portal\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"shadow\",\n  \"slot\",\n  \"small\",\n  \"source\",\n  \"spacer\",\n  \"span\",\n  \"strike\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"tt\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  \"xmp\",\n  \"input\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\"\n]);\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? (bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart]) : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document\n      ? code()\n      : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, isImportNode, isSVG, isMathML) {\n  let node;\n  const create = () => {\n    const t = isMathML\n      ? document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"template\")\n      : document.createElement(\"template\");\n    t.innerHTML = html;\n    return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;\n  };\n  const fn = isImportNode\n    ? () => untrack(() => document.importNode(node || (node = create()), true))\n    : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setProperty(node, name, value) {\n  if (isHydrating(node)) return;\n  node[name] = value;\n}\nfunction setAttribute(node, name, value) {\n  if (isHydrating(node)) return;\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (isHydrating(node)) return;\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction setBoolAttribute(node, name, value) {\n  if (isHydrating(node)) return;\n  value ? node.setAttribute(name, \"\") : node.removeAttribute(name);\n}\nfunction className(node, value) {\n  if (isHydrating(node)) return;\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, (handler[0] = e => handlerFn.call(node, handler[1], e)));\n  } else node.addEventListener(name, handler, typeof handler !== \"function\" && handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n    prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n      classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return (nodeStyle.cssText = value);\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    createRenderEffect(\n      () => (prevProps.children = insertExpression(node, props.children, prevProps.children))\n    );\n  }\n  createRenderEffect(() => typeof props.ref === \"function\" && use(props.ref, node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  if (globalThis._$HY.done) return render(code, element, [...element.childNodes], options);\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = id => globalThis._$HY.r[id];\n  sharedConfig.has = id => id in globalThis._$HY.r;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  try {\n    gatherHydratable(element, options.renderId);\n    return render(code, element, [...element.childNodes], options);\n  } finally {\n    sharedConfig.context = null;\n  }\n}\nfunction getNextElement(template) {\n  let node,\n    key,\n    hydrating = isHydrating();\n  if (!hydrating || !(node = sharedConfig.registry.get((key = getHydrationKey())))) {\n    return template();\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n    count = 0,\n    current = [];\n  if (isHydrating(start)) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"$\") count++;\n        else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const { completed, events } = sharedConfig;\n      if (!events) return;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        events.shift();\n        eventHandler(e);\n      }\n      if (sharedConfig.done) {\n        sharedConfig.events = _$HY.events = null;\n        sharedConfig.completed = _$HY.completed = null;\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction isHydrating(node) {\n  return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)\n    node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef, props) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev, typeof prev !== \"function\" && prev);\n    value && node.addEventListener(e, value, typeof value !== \"function\" && value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (prop.slice(0, 5) === \"bool:\") {\n    setBoolAttribute(node, prop.slice(5), value);\n  } else if (\n    (forceProp = prop.slice(0, 5) === \"prop:\") ||\n    (isChildProp = ChildProperties.has(prop)) ||\n    (!isSVG &&\n      ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop)))) ||\n    (isCE = node.nodeName.includes(\"-\") || \"is\" in props)\n  ) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    } else if (isHydrating(node)) return value;\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  if (sharedConfig.registry && sharedConfig.events) {\n    if (sharedConfig.events.find(([el, ev]) => ev === e)) return;\n  }\n  let node = e.target;\n  const key = `$$${e.type}`;\n  const oriTarget = e.target;\n  const oriCurrentTarget = e.currentTarget;\n  const retarget = value =>\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value\n    });\n  const handleNode = () => {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node.host &&\n      typeof node.host !== \"string\" &&\n      !node.host._$host &&\n      node.contains(e.target) &&\n      retarget(node.host);\n    return true;\n  };\n  const walkUpTree = () => {\n    while (handleNode() && (node = node._$host || node.parentNode || node.host));\n  };\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;\n  if (e.composedPath) {\n    const path = e.composedPath();\n    retarget(path[0]);\n    for (let i = 0; i < path.length - 2; i++) {\n      node = path[i];\n      if (!handleNode()) break;\n      if (node._$host) {\n        node = node._$host;\n        walkUpTree();\n        break;\n      }\n      if (node.parentNode === oriCurrentTarget) {\n        break;\n      }\n    }\n  } else walkUpTree();\n  retarget(oriTarget);\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  const hydrating = isHydrating(parent);\n  if (hydrating) {\n    !current && (current = [...parent.childNodes]);\n    let cleaned = [];\n    for (let i = 0; i < current.length; i++) {\n      const node = current[i];\n      if (node.nodeType === 8 && node.data.slice(0, 2) === \"!$\") node.remove();\n      else cleaned.push(node);\n    }\n    current = cleaned;\n  }\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = (multi && current[0] && current[0].parentNode) || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (hydrating) return current;\n    if (t === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (hydrating) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => (current = insertExpression(parent, array, current, marker, true)));\n      return () => current;\n    }\n    if (hydrating) {\n      if (!array.length) return current;\n      if (marker === undefined) return (current = [...parent.childNodes]);\n      let node = array[0];\n      if (node.parentNode !== parent) return current;\n      const nodes = [node];\n      while ((node = node.nextSibling) !== marker) nodes.push(node);\n      return (current = nodes);\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (hydrating && value.parentNode) return (current = multi ? [value] : value);\n    if (Array.isArray(current)) {\n      if (multi) return (current = cleanChildren(parent, current, marker, value));\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[normalized.length],\n      t;\n    if (item == null || item === true || item === false);\n    else if ((t = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic =\n          normalizeIncomingArray(\n            normalized,\n            Array.isArray(item) ? item : [item],\n            Array.isArray(prev) ? prev : [prev]\n          ) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return (parent.textContent = \"\");\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i)\n          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key))\n      sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  return sharedConfig.getNextContextId();\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\nfunction Hydration(props) {\n  return props.children;\n}\nconst voidFn = () => undefined;\nconst RequestContext = Symbol();\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction ssrElement(name, props, children, needsId) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction resolveSSRNode(node) {}\nfunction escape(html) {}\nfunction ssrSpread(props, isSVG, skipChildren) {}\n\nconst isServer = false;\nconst isDev = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const { useShadow } = props,\n    marker = document.createTextNode(\"\"),\n    mount = () => props.mount || document.body,\n    owner = getOwner();\n  let content;\n  let hydrating = !!sharedConfig.context;\n  createEffect(\n    () => {\n      if (hydrating) getOwner().user = hydrating = false;\n      content || (content = runWithOwner(owner, () => createMemo(() => props.children)));\n      const el = mount();\n      if (el instanceof HTMLHeadElement) {\n        const [clean, setClean] = createSignal(false);\n        const cleanup = () => setClean(true);\n        createRoot(dispose => insert(el, () => (!clean() ? content() : dispose()), null));\n        onCleanup(cleanup);\n      } else {\n        const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot =\n            useShadow && container.attachShadow\n              ? container.attachShadow({\n                  mode: \"open\"\n                })\n              : container;\n        Object.defineProperty(container, \"_$host\", {\n          get() {\n            return marker.parentNode;\n          },\n          configurable: true\n        });\n        insert(renderRoot, content);\n        el.appendChild(container);\n        props.ref && props.ref(container);\n        onCleanup(() => el.removeChild(container));\n      }\n    },\n    undefined,\n    {\n      render: !hydrating\n    }\n  );\n  return marker;\n}\nfunction createDynamic(component, props) {\n  const cached = createMemo(component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(props));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, props, isSvg);\n        return el;\n    }\n  });\n}\nfunction Dynamic(props) {\n  const [, others] = splitProps(props, [\"component\"]);\n  return createDynamic(() => props.component, others);\n}\n\nexport {\n  Aliases,\n  voidFn as Assets,\n  ChildProperties,\n  DOMElements,\n  DelegatedEvents,\n  Dynamic,\n  Hydration,\n  voidFn as HydrationScript,\n  NoHydration,\n  Portal,\n  Properties,\n  RequestContext,\n  SVGElements,\n  SVGNamespace,\n  addEventListener,\n  assign,\n  classList,\n  className,\n  clearDelegatedEvents,\n  createDynamic,\n  delegateEvents,\n  dynamicProperty,\n  escape,\n  voidFn as generateHydrationScript,\n  voidFn as getAssets,\n  getHydrationKey,\n  getNextElement,\n  getNextMarker,\n  getNextMatch,\n  getPropAlias,\n  voidFn as getRequestEvent,\n  hydrate,\n  innerHTML,\n  insert,\n  isDev,\n  isServer,\n  render,\n  renderToStream,\n  renderToString,\n  renderToStringAsync,\n  resolveSSRNode,\n  runHydrationEvents,\n  setAttribute,\n  setAttributeNS,\n  setBoolAttribute,\n  setProperty,\n  spread,\n  ssr,\n  ssrAttribute,\n  ssrClassList,\n  ssrElement,\n  ssrHydrationKey,\n  ssrSpread,\n  ssrStyle,\n  style,\n  template,\n  use,\n  voidFn as useAssets\n};\n","import {\n  effect,\n  style,\n  insert,\n  untrack,\n  spread,\n  createComponent,\n  delegateEvents,\n  classList,\n  mergeProps,\n  dynamicProperty,\n  setAttribute,\n  setAttributeNS,\n  addEventListener,\n  Aliases,\n  getPropAlias,\n  Properties,\n  ChildProperties,\n  DelegatedEvents,\n  SVGElements,\n  SVGNamespace\n} from \"solid-js/web\";\n\nconst tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\nconst attrRE =\n  /(?:\\s(?<boolean>[^/\\s><=]+?)(?=[\\s/>]))|(?:(?<name>\\S+?)(?:\\s*=\\s*(?:(['\"])(?<quotedValue>[\\s\\S]*?)\\3|(?<unquotedValue>[^\\s>]+))))/g;\nconst lookup = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  menuitem: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\nfunction parseTag(tag) {\n  const res = {\n    type: \"tag\",\n    name: \"\",\n    voidElement: false,\n    attrs: [],\n    children: []\n  };\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/);\n  if (tagMatch) {\n    res.name = tagMatch[1];\n    if (lookup[tagMatch[1].toLowerCase()] || tag.charAt(tag.length - 2) === \"/\") {\n      res.voidElement = true;\n    }\n    if (res.name.startsWith(\"!--\")) {\n      const endIndex = tag.indexOf(\"-->\");\n      return {\n        type: \"comment\",\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : \"\"\n      };\n    }\n  }\n  const reg = new RegExp(attrRE);\n  for (const match of tag.matchAll(reg)) {\n    if ((match[1] || match[2]).startsWith(\"use:\")) {\n      res.attrs.push({\n        type: \"directive\",\n        name: match[1] || match[2],\n        value: match[4] || match[5] || \"\"\n      });\n    } else {\n      res.attrs.push({\n        type: \"attr\",\n        name: match[1] || match[2],\n        value: match[4] || match[5] || \"\"\n      });\n    }\n  }\n  return res;\n}\nfunction pushTextNode(list, html, start) {\n  const end = html.indexOf(\"<\", start);\n  const content = html.slice(start, end === -1 ? undefined : end);\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: \"text\",\n      content: content\n    });\n  }\n}\nfunction pushCommentNode(list, tag) {\n  const content = tag.replace(\"<!--\", \"\").replace(\"-->\", \"\");\n  if (!/^\\s*$/.test(content)) {\n    list.push({\n      type: \"comment\",\n      content: content\n    });\n  }\n}\nfunction parse(html) {\n  const result = [];\n  let current = undefined;\n  let level = -1;\n  const arr = [];\n  const byTag = {};\n  html.replace(tagRE, (tag, index) => {\n    const isOpen = tag.charAt(1) !== \"/\";\n    const isComment = tag.slice(0, 4) === \"<!--\";\n    const start = index + tag.length;\n    const nextChar = html.charAt(start);\n    let parent = undefined;\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n      if (!current.voidElement && nextChar && nextChar !== \"<\") {\n        pushTextNode(current.children, html, start);\n      }\n      byTag[current.tagName] = current;\n      if (level === 0) {\n        result.push(current);\n      }\n      parent = arr[level - 1];\n      if (parent) {\n        parent.children.push(current);\n      }\n      arr[level] = current;\n    }\n    if (isComment) {\n      if (level < 0) {\n        pushCommentNode(result, tag);\n      } else {\n        pushCommentNode(arr[level].children, tag);\n      }\n    }\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n      if (nextChar !== \"<\" && nextChar) {\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, start);\n      }\n    }\n  });\n  return result;\n}\nfunction attrString(attrs) {\n  const buff = [];\n  for (const attr of attrs) {\n    buff.push(attr.name + '=\"' + attr.value.replace(/\"/g, \"&quot;\") + '\"');\n  }\n  if (!buff.length) {\n    return \"\";\n  }\n  return \" \" + buff.join(\" \");\n}\nfunction stringifier(buff, doc) {\n  switch (doc.type) {\n    case \"text\":\n      return buff + doc.content;\n    case \"tag\":\n      buff +=\n        \"<\" + doc.name + (doc.attrs ? attrString(doc.attrs) : \"\") + (doc.voidElement ? \"/>\" : \">\");\n      if (doc.voidElement) {\n        return buff;\n      }\n      return buff + doc.children.reduce(stringifier, \"\") + \"</\" + doc.name + \">\";\n    case \"comment\":\n      return (buff += \"<!--\" + doc.content + \"-->\");\n  }\n}\nfunction stringify(doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringifier(\"\", rootEl);\n  }, \"\");\n}\nconst cache = new Map();\nconst VOID_ELEMENTS =\n  /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst spaces = \" \\\\f\\\\n\\\\r\\\\t\";\nconst almostEverything = \"[^\" + spaces + \"\\\\/>\\\"'=]+\";\nconst attrName = \"[ \" + spaces + \"]+(?:use:<!--#-->|\" + almostEverything + \")\";\nconst tagName = \"<([A-Za-z$#]+[A-Za-z0-9:_-]*)((?:\";\nconst attrPartials =\n  \"(?:\\\\s*=\\\\s*(?:'[^']*?'|\\\"[^\\\"]*?\\\"|\\\\([^)]*?\\\\)|<[^>]*?>|\" + almostEverything + \"))?)\";\nconst attrSeeker = new RegExp(tagName + attrName + attrPartials + \"+)([ \" + spaces + \"]*/?>)\", \"g\");\nconst findAttributes = new RegExp(\n  \"(\" + attrName + \"\\\\s*=\\\\s*)(<!--#-->|['\\\"(]([\\\\w\\\\s]*<!--#-->[\\\\w\\\\s]*)*['\\\")])\",\n  \"gi\"\n);\nconst selfClosing = new RegExp(tagName + attrName + attrPartials + \"*)([ \" + spaces + \"]*/>)\", \"g\");\nconst marker = \"<!--#-->\";\nconst reservedNameSpaces = new Set([\"class\", \"on\", \"oncapture\", \"style\", \"use\", \"prop\", \"attr\"]);\nfunction attrReplacer($0, $1, $2, $3) {\n  return \"<\" + $1 + $2.replace(findAttributes, replaceAttributes) + $3;\n}\nfunction replaceAttributes($0, $1, $2) {\n  return (\n    $1.replace(/<!--#-->/g, \"###\") +\n    ($2[0] === '\"' || $2[0] === \"'\" ? $2.replace(/<!--#-->/g, \"###\") : '\"###\"')\n  );\n}\nfunction fullClosing($0, $1, $2) {\n  return VOID_ELEMENTS.test($1) ? $0 : \"<\" + $1 + $2 + \"></\" + $1 + \">\";\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction parseDirective(name, value, tag, options) {\n  if (name === \"use:###\" && value === \"###\") {\n    const count = options.counter++;\n    options.exprs.push(\n      `typeof exprs[${count}] === \"function\" ? r.use(exprs[${count}], ${tag}, exprs[${options.counter++}]) : (()=>{throw new Error(\"use:### must be a function\")})()`\n    );\n  } else {\n    throw new Error(`Not support syntax ${name} must be use:{function}`);\n  }\n}\nfunction createHTML(\n  r,\n  { delegateEvents = true, functionBuilder = (...args) => new Function(...args) } = {}\n) {\n  let uuid = 1;\n  r.wrapProps = props => {\n    const d = Object.getOwnPropertyDescriptors(props);\n    for (const k in d) {\n      if (typeof d[k].value === \"function\" && !d[k].value.length) r.dynamicProperty(props, k);\n    }\n    return props;\n  };\n  function createTemplate(statics, opt) {\n    let i = 0,\n      markup = \"\";\n    for (; i < statics.length - 1; i++) {\n      markup = markup + statics[i] + \"<!--#-->\";\n    }\n    markup = markup + statics[i];\n    const replaceList = [\n      [selfClosing, fullClosing],\n      [/<(<!--#-->)/g, \"<###\"],\n      [/\\.\\.\\.(<!--#-->)/g, \"###\"],\n      [attrSeeker, attrReplacer],\n      [/>\\n+\\s*/g, \">\"],\n      [/\\n+\\s*</g, \"<\"],\n      [/\\s+</g, \" <\"],\n      [/>\\s+/g, \"> \"]\n    ];\n    markup = replaceList.reduce((acc, x) => {\n      return acc.replace(x[0], x[1]);\n    }, markup);\n    const pars = parse(markup);\n    const [html, code] = parseTemplate(pars, opt.funcBuilder),\n      templates = [];\n    for (let i = 0; i < html.length; i++) {\n      templates.push(document.createElement(\"template\"));\n      templates[i].innerHTML = html[i];\n      const nomarkers = templates[i].content.querySelectorAll(\"script,style\");\n      for (let j = 0; j < nomarkers.length; j++) {\n        const d = nomarkers[j].firstChild?.data || \"\";\n        if (d.indexOf(marker) > -1) {\n          const parts = d.split(marker).reduce((memo, p, i) => {\n            i && memo.push(\"\");\n            memo.push(p);\n            return memo;\n          }, []);\n          nomarkers[i].firstChild.replaceWith(...parts);\n        }\n      }\n    }\n    templates[0].create = code;\n    cache.set(statics, templates);\n    return templates;\n  }\n  function parseKeyValue(node, tag, name, value, isSVG, isCE, options) {\n    let expr =\n        value === \"###\"\n          ? `!doNotWrap ? exprs[${options.counter}]() : exprs[${options.counter++}]`\n          : value\n              .split(\"###\")\n              .map((v, i) =>\n                i\n                  ? ` + (typeof exprs[${options.counter}] === \"function\" ? exprs[${\n                      options.counter\n                    }]() : exprs[${options.counter++}]) + \"${v}\"`\n                  : `\"${v}\"`\n              )\n              .join(\"\"),\n      parts,\n      namespace;\n    if ((parts = name.split(\":\")) && parts[1] && reservedNameSpaces.has(parts[0])) {\n      name = parts[1];\n      namespace = parts[0];\n    }\n    const isChildProp = r.ChildProperties.has(name);\n    const isProp = r.Properties.has(name);\n    if (name === \"style\") {\n      const prev = `_$v${uuid++}`;\n      options.decl.push(`${prev}={}`);\n      options.exprs.push(`r.style(${tag},${expr},${prev})`);\n    } else if (name === \"classList\") {\n      const prev = `_$v${uuid++}`;\n      options.decl.push(`${prev}={}`);\n      options.exprs.push(`r.classList(${tag},${expr},${prev})`);\n    } else if (\n      namespace !== \"attr\" &&\n      (isChildProp ||\n        (!isSVG && (r.getPropAlias(name, node.name.toUpperCase()) || isProp)) ||\n        isCE ||\n        namespace === \"prop\")\n    ) {\n      if (isCE && !isChildProp && !isProp && namespace !== \"prop\") name = toPropertyName(name);\n      options.exprs.push(\n        `${tag}.${r.getPropAlias(name, node.name.toUpperCase()) || name} = ${expr}`\n      );\n    } else {\n      const ns = isSVG && name.indexOf(\":\") > -1 && r.SVGNamespace[name.split(\":\")[0]];\n      if (ns) options.exprs.push(`r.setAttributeNS(${tag},\"${ns}\",\"${name}\",${expr})`);\n      else options.exprs.push(`r.setAttribute(${tag},\"${r.Aliases[name] || name}\",${expr})`);\n    }\n  }\n  function parseAttribute(node, tag, name, value, isSVG, isCE, options) {\n    if (name.slice(0, 2) === \"on\") {\n      if (!name.includes(\":\")) {\n        const lc = name.slice(2).toLowerCase();\n        const delegate = delegateEvents && r.DelegatedEvents.has(lc);\n        options.exprs.push(\n          `r.addEventListener(${tag},\"${lc}\",exprs[${options.counter++}],${delegate})`\n        );\n        delegate && options.delegatedEvents.add(lc);\n      } else {\n        let capture = name.startsWith(\"oncapture:\");\n        options.exprs.push(\n          `${tag}.addEventListener(\"${name.slice(capture ? 10 : 3)}\",exprs[${options.counter++}]${\n            capture ? \",true\" : \"\"\n          })`\n        );\n      }\n    } else if (name === \"ref\") {\n      options.exprs.push(`exprs[${options.counter++}](${tag})`);\n    } else {\n      const childOptions = Object.assign({}, options, {\n          exprs: []\n        }),\n        count = options.counter;\n      parseKeyValue(node, tag, name, value, isSVG, isCE, childOptions);\n      options.decl.push(\n        `_fn${count} = (${value === \"###\" ? \"doNotWrap\" : \"\"}) => {\\n${childOptions.exprs.join(\n          \";\\n\"\n        )};\\n}`\n      );\n      if (value === \"###\") {\n        options.exprs.push(\n          `typeof exprs[${count}] === \"function\" ? r.effect(_fn${count}) : _fn${count}(true)`\n        );\n      } else {\n        let check = \"\";\n        for (let i = count; i < childOptions.counter; i++) {\n          i !== count && (check += \" || \");\n          check += `typeof exprs[${i}] === \"function\"`;\n        }\n        options.exprs.push(check + ` ? r.effect(_fn${count}) : _fn${count}()`);\n      }\n      options.counter = childOptions.counter;\n      options.wrap = false;\n    }\n  }\n  function processChildren(node, options) {\n    const childOptions = Object.assign({}, options, {\n      first: true,\n      multi: false,\n      parent: options.path\n    });\n    if (node.children.length > 1) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (\n          (child.type === \"comment\" && child.content === \"#\") ||\n          (child.type === \"tag\" && child.name === \"###\")\n        ) {\n          childOptions.multi = true;\n          break;\n        }\n      }\n    }\n    let i = 0;\n    while (i < node.children.length) {\n      const child = node.children[i];\n      if (child.name === \"###\") {\n        if (childOptions.multi) {\n          node.children[i] = {\n            type: \"comment\",\n            content: \"#\"\n          };\n          i++;\n        } else node.children.splice(i, 1);\n        processComponent(child, childOptions);\n        continue;\n      }\n      parseNode(child, childOptions);\n      if (!childOptions.multi && child.type === \"comment\" && child.content === \"#\")\n        node.children.splice(i, 1);\n      else i++;\n    }\n    options.counter = childOptions.counter;\n    options.templateId = childOptions.templateId;\n    options.hasCustomElement = options.hasCustomElement || childOptions.hasCustomElement;\n    options.isImportNode = options.isImportNode || childOptions.isImportNode;\n  }\n  function processComponentProps(propGroups) {\n    let result = [];\n    for (const props of propGroups) {\n      if (Array.isArray(props)) {\n        if (!props.length) continue;\n        result.push(`r.wrapProps({${props.join(\",\") || \"\"}})`);\n      } else result.push(props);\n    }\n    return result.length > 1 ? `r.mergeProps(${result.join(\",\")})` : result[0];\n  }\n  function processComponent(node, options) {\n    let props = [];\n    const keys = Object.keys(node.attrs),\n      propGroups = [props],\n      componentIdentifier = options.counter++;\n    for (let i = 0; i < keys.length; i++) {\n      const { type, name, value } = node.attrs[i];\n      if (type === \"attr\") {\n        if (name === \"###\") {\n          propGroups.push(`exprs[${options.counter++}]`);\n          propGroups.push((props = []));\n        } else if (value === \"###\") {\n          props.push(`${name}: exprs[${options.counter++}]`);\n        } else props.push(`${name}: \"${value}\"`);\n      } else if (type === \"directive\") {\n        const tag = `_$el${uuid++}`;\n        const topDecl = !options.decl.length;\n        options.decl.push(\n          topDecl ? \"\" : `${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`\n        );\n        parseDirective(name, value, tag, options);\n      }\n    }\n    if (\n      node.children.length === 1 &&\n      node.children[0].type === \"comment\" &&\n      node.children[0].content === \"#\"\n    ) {\n      props.push(`children: () => exprs[${options.counter++}]`);\n    } else if (node.children.length) {\n      const children = {\n          type: \"fragment\",\n          children: node.children\n        },\n        childOptions = Object.assign({}, options, {\n          first: true,\n          decl: [],\n          exprs: [],\n          parent: false\n        });\n      parseNode(children, childOptions);\n      props.push(`children: () => { ${childOptions.exprs.join(\";\\n\")}}`);\n      options.templateId = childOptions.templateId;\n      options.counter = childOptions.counter;\n    }\n    let tag;\n    if (options.multi) {\n      tag = `_$el${uuid++}`;\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n    }\n    if (options.parent)\n      options.exprs.push(\n        `r.insert(${\n          options.parent\n        }, r.createComponent(exprs[${componentIdentifier}],${processComponentProps(propGroups)})${\n          tag ? `, ${tag}` : \"\"\n        })`\n      );\n    else\n      options.exprs.push(\n        `${\n          options.fragment ? \"\" : \"return \"\n        }r.createComponent(exprs[${componentIdentifier}],${processComponentProps(propGroups)})`\n      );\n    options.path = tag;\n    options.first = false;\n  }\n  function parseNode(node, options) {\n    if (node.type === \"fragment\") {\n      const parts = [];\n      node.children.forEach(child => {\n        if (child.type === \"tag\") {\n          if (child.name === \"###\") {\n            const childOptions = Object.assign({}, options, {\n              first: true,\n              fragment: true,\n              decl: [],\n              exprs: []\n            });\n            processComponent(child, childOptions);\n            parts.push(childOptions.exprs[0]);\n            options.counter = childOptions.counter;\n            options.templateId = childOptions.templateId;\n            return;\n          }\n          options.templateId++;\n          const id = uuid;\n          const childOptions = Object.assign({}, options, {\n            first: true,\n            decl: [],\n            exprs: []\n          });\n          options.templateNodes.push([child]);\n          parseNode(child, childOptions);\n          parts.push(\n            `function() { ${\n              childOptions.decl.join(\",\\n\") +\n              \";\\n\" +\n              childOptions.exprs.join(\";\\n\") +\n              `;\\nreturn _$el${id};\\n`\n            }}()`\n          );\n          options.counter = childOptions.counter;\n          options.templateId = childOptions.templateId;\n        } else if (child.type === \"text\") {\n          parts.push(`\"${child.content}\"`);\n        } else if (child.type === \"comment\") {\n          if (child.content === \"#\") parts.push(`exprs[${options.counter++}]`);\n          else if (child.content) {\n            for (let i = 0; i < child.content.split(\"###\").length - 1; i++) {\n              parts.push(`exprs[${options.counter++}]`);\n            }\n          }\n        }\n      });\n      options.exprs.push(`return [${parts.join(\", \\n\")}]`);\n    } else if (node.type === \"tag\") {\n      const tag = `_$el${uuid++}`;\n      const topDecl = !options.decl.length;\n      const templateId = options.templateId;\n      options.decl.push(\n        topDecl ? \"\" : `${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`\n      );\n      const isSVG = r.SVGElements.has(node.name);\n      const isCE = node.name.includes(\"-\") || node.attrs.some(e => e.name === \"is\");\n      options.hasCustomElement = isCE;\n      options.isImportNode =\n        (node.name === \"img\" || node.name === \"iframe\") &&\n        node.attrs.some(e => e.name === \"loading\" && e.value === \"lazy\");\n      if (node.attrs.some(e => e.name === \"###\")) {\n        const spreadArgs = [];\n        let current = \"\";\n        const newAttrs = [];\n        for (let i = 0; i < node.attrs.length; i++) {\n          const { type, name, value } = node.attrs[i];\n          if (type === \"attr\") {\n            if (value.includes(\"###\")) {\n              let count = options.counter++;\n              current += `${name}: ${\n                name !== \"ref\" ? `typeof exprs[${count}] === \"function\" ? exprs[${count}]() : ` : \"\"\n              }exprs[${count}],`;\n            } else if (name === \"###\") {\n              if (current.length) {\n                spreadArgs.push(`()=>({${current}})`);\n                current = \"\";\n              }\n              spreadArgs.push(`exprs[${options.counter++}]`);\n            } else {\n              newAttrs.push(node.attrs[i]);\n            }\n          } else if (type === \"directive\") {\n            parseDirective(name, value, tag, options);\n          }\n        }\n        node.attrs = newAttrs;\n        if (current.length) {\n          spreadArgs.push(`()=>({${current}})`);\n        }\n        options.exprs.push(\n          `r.spread(${tag},${\n            spreadArgs.length === 1\n              ? `typeof ${spreadArgs[0]} === \"function\" ? r.mergeProps(${spreadArgs[0]}) : ${spreadArgs[0]}`\n              : `r.mergeProps(${spreadArgs.join(\",\")})`\n          },${isSVG},${!!node.children.length})`\n        );\n      } else {\n        for (let i = 0; i < node.attrs.length; i++) {\n          const { type, name, value } = node.attrs[i];\n          if (type === \"directive\") {\n            parseDirective(name, value, tag, options);\n            node.attrs.splice(i, 1);\n            i--;\n          } else if (type === \"attr\") {\n            if (value.includes(\"###\")) {\n              node.attrs.splice(i, 1);\n              i--;\n              parseAttribute(node, tag, name, value, isSVG, isCE, options);\n            }\n          }\n        }\n      }\n      options.path = tag;\n      options.first = false;\n      processChildren(node, options);\n      if (topDecl) {\n        options.decl[0] =\n          options.hasCustomElement || options.isImportNode\n            ? `const ${tag} = r.untrack(() => document.importNode(tmpls[${templateId}].content.firstChild, true))`\n            : `const ${tag} = tmpls[${templateId}].content.firstChild.cloneNode(true)`;\n      }\n    } else if (node.type === \"text\") {\n      const tag = `_$el${uuid++}`;\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n      options.path = tag;\n      options.first = false;\n    } else if (node.type === \"comment\") {\n      const tag = `_$el${uuid++}`;\n      options.decl.push(`${tag} = ${options.path}.${options.first ? \"firstChild\" : \"nextSibling\"}`);\n      if (node.content === \"#\") {\n        if (options.multi) {\n          options.exprs.push(`r.insert(${options.parent}, exprs[${options.counter++}], ${tag})`);\n        } else options.exprs.push(`r.insert(${options.parent}, exprs[${options.counter++}])`);\n      }\n      options.path = tag;\n      options.first = false;\n    }\n  }\n  function parseTemplate(nodes, funcBuilder) {\n    const options = {\n        path: \"\",\n        decl: [],\n        exprs: [],\n        delegatedEvents: new Set(),\n        counter: 0,\n        first: true,\n        multi: false,\n        templateId: 0,\n        templateNodes: []\n      },\n      id = uuid,\n      origNodes = nodes;\n    let toplevel;\n    if (nodes.length > 1) {\n      nodes = [\n        {\n          type: \"fragment\",\n          children: nodes\n        }\n      ];\n    }\n    if (nodes[0].name === \"###\") {\n      toplevel = true;\n      processComponent(nodes[0], options);\n    } else parseNode(nodes[0], options);\n    r.delegateEvents(Array.from(options.delegatedEvents));\n    const templateNodes = [origNodes].concat(options.templateNodes);\n    return [\n      templateNodes.map(t => stringify(t)),\n      funcBuilder(\n        \"tmpls\",\n        \"exprs\",\n        \"r\",\n        options.decl.join(\",\\n\") +\n          \";\\n\" +\n          options.exprs.join(\";\\n\") +\n          (toplevel ? \"\" : `;\\nreturn _$el${id};\\n`)\n      )\n    ];\n  }\n  function html(statics, ...args) {\n    const templates =\n      cache.get(statics) ||\n      createTemplate(statics, {\n        funcBuilder: functionBuilder\n      });\n    return templates[0].create(templates, args, r);\n  }\n  return html;\n}\n\nconst html = createHTML({\n  effect,\n  style,\n  insert,\n  untrack,\n  spread,\n  createComponent,\n  delegateEvents,\n  classList,\n  mergeProps,\n  dynamicProperty,\n  setAttribute,\n  setAttributeNS,\n  addEventListener,\n  Aliases,\n  getPropAlias,\n  Properties,\n  ChildProperties,\n  DelegatedEvents,\n  SVGElements,\n  SVGNamespace\n});\n\nexport { html as default };\n","import { isServer, getRequestEvent, createComponent as createComponent$1, memo, delegateEvents, spread, mergeProps as mergeProps$1, template } from 'solid-js/web';\nimport { getOwner, runWithOwner, createMemo, createContext, onCleanup, useContext, untrack, createSignal, createRenderEffect, on, startTransition, resetErrorBoundaries, batch, createComponent, children, mergeProps, Show, createRoot, sharedConfig, getListener, $TRACK, splitProps, createResource } from 'solid-js';\nimport { createStore, reconcile, unwrap } from 'solid-js/store';\n\nfunction createBeforeLeave() {\n  let listeners = new Set();\n  function subscribe(listener) {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  }\n  let ignore = false;\n  function confirm(to, options) {\n    if (ignore) return !(ignore = false);\n    const e = {\n      to,\n      options,\n      defaultPrevented: false,\n      preventDefault: () => e.defaultPrevented = true\n    };\n    for (const l of listeners) l.listener({\n      ...e,\n      from: l.location,\n      retry: force => {\n        force && (ignore = true);\n        l.navigate(to, {\n          ...options,\n          resolve: false\n        });\n      }\n    });\n    return !e.defaultPrevented;\n  }\n  return {\n    subscribe,\n    confirm\n  };\n}\n\n// The following supports browser initiated blocking (eg back/forward)\n\nlet depth;\nfunction saveCurrentDepth() {\n  if (!window.history.state || window.history.state._depth == null) {\n    window.history.replaceState({\n      ...window.history.state,\n      _depth: window.history.length - 1\n    }, \"\");\n  }\n  depth = window.history.state._depth;\n}\nif (!isServer) {\n  saveCurrentDepth();\n}\nfunction keepDepth(state) {\n  return {\n    ...state,\n    _depth: window.history.state && window.history.state._depth\n  };\n}\nfunction notifyIfNotBlocked(notify, block) {\n  let ignore = false;\n  return () => {\n    const prevDepth = depth;\n    saveCurrentDepth();\n    const delta = prevDepth == null ? null : depth - prevDepth;\n    if (ignore) {\n      ignore = false;\n      return;\n    }\n    if (delta && block(delta)) {\n      ignore = true;\n      window.history.go(-delta);\n    } else {\n      notify();\n    }\n  };\n}\n\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\nconst mockBase = \"http://sr\";\nfunction normalizePath(path, omitSlash = false) {\n  const s = path.replace(trimPathRegex, \"$1\");\n  return s ? omitSlash || /^[?#]/.test(s) ? s : \"/\" + s : \"\";\n}\nfunction resolvePath(base, path, from) {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalizePath(base);\n  const fromPath = from && normalizePath(from);\n  let result = \"\";\n  if (!fromPath || path.startsWith(\"/\")) {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return (result || \"/\") + normalizePath(path, !result);\n}\nfunction invariant(value, message) {\n  if (value == null) {\n    throw new Error(message);\n  }\n  return value;\n}\nfunction joinPaths(from, to) {\n  return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\n}\nfunction extractSearchParams(url) {\n  const params = {};\n  url.searchParams.forEach((value, key) => {\n    if (key in params) {\n      if (Array.isArray(params[key])) params[key].push(value);else params[key] = [params[key], value];\n    } else params[key] = value;\n  });\n  return params;\n}\nfunction createMatcher(path, partial, matchFilters) {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  return location => {\n    const locSegments = location.split(\"/\").filter(Boolean);\n    const lenDiff = locSegments.length - len;\n    if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {\n      return null;\n    }\n    const match = {\n      path: len ? \"\" : \"/\",\n      params: {}\n    };\n    const matchFilter = s => matchFilters === undefined ? undefined : matchFilters[s];\n    for (let i = 0; i < len; i++) {\n      const segment = segments[i];\n      const dynamic = segment[0] === \":\";\n      const locSegment = dynamic ? locSegments[i] : locSegments[i].toLowerCase();\n      const key = dynamic ? segment.slice(1) : segment.toLowerCase();\n      if (dynamic && matchSegment(locSegment, matchFilter(key))) {\n        match.params[key] = locSegment;\n      } else if (dynamic || !matchSegment(locSegment, key)) {\n        return null;\n      }\n      match.path += `/${locSegment}`;\n    }\n    if (splat) {\n      const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n      if (matchSegment(remainder, matchFilter(splat))) {\n        match.params[splat] = remainder;\n      } else {\n        return null;\n      }\n    }\n    return match;\n  };\n}\nfunction matchSegment(input, filter) {\n  const isEqual = s => s === input;\n  if (filter === undefined) {\n    return true;\n  } else if (typeof filter === \"string\") {\n    return isEqual(filter);\n  } else if (typeof filter === \"function\") {\n    return filter(input);\n  } else if (Array.isArray(filter)) {\n    return filter.some(isEqual);\n  } else if (filter instanceof RegExp) {\n    return filter.test(input);\n  }\n  return false;\n}\nfunction scoreRoute(route) {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nfunction createMemoObject(fn) {\n  const map = new Map();\n  const owner = getOwner();\n  return new Proxy({}, {\n    get(_, property) {\n      if (!map.has(property)) {\n        runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n      }\n      return map.get(property)();\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    },\n    ownKeys() {\n      return Reflect.ownKeys(fn());\n    }\n  });\n}\nfunction mergeSearchString(search, params) {\n  const merged = new URLSearchParams(search);\n  Object.entries(params).forEach(([key, value]) => {\n    if (value == null || value === \"\" || value instanceof Array && !value.length) {\n      merged.delete(key);\n    } else {\n      if (value instanceof Array) {\n        // Delete all instances of the key before appending\n        merged.delete(key);\n        value.forEach(v => {\n          merged.append(key, String(v));\n        });\n      } else {\n        merged.set(key, String(value));\n      }\n    }\n  });\n  const s = merged.toString();\n  return s ? `?${s}` : \"\";\n}\nfunction expandOptionals(pattern) {\n  let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n  if (!match) return [pattern];\n  let prefix = pattern.slice(0, match.index);\n  let suffix = pattern.slice(match.index + match[0].length);\n  const prefixes = [prefix, prefix += match[1]];\n\n  // This section handles adjacent optional params. We don't actually want all permuations since\n  // that will lead to equivalent routes which have the same number of params. For example\n  // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n  // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n  // ensure predictability where earlier params have precidence.\n  while (match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix)) {\n    prefixes.push(prefix += match[1]);\n    suffix = suffix.slice(match[0].length);\n  }\n  return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n\nconst MAX_REDIRECTS = 100;\nconst RouterContextObj = createContext();\nconst RouteContextObj = createContext();\nconst useRouter = () => invariant(useContext(RouterContextObj), \"<A> and 'use' router primitives can be only used inside a Route.\");\nconst useRoute = () => useContext(RouteContextObj) || useRouter().base;\nconst useResolvedPath = path => {\n  const route = useRoute();\n  return createMemo(() => route.resolvePath(path()));\n};\nconst useHref = to => {\n  const router = useRouter();\n  return createMemo(() => {\n    const to_ = to();\n    return to_ !== undefined ? router.renderPath(to_) : to_;\n  });\n};\n\n/**\n * Retrieves method to do navigation. The method accepts a path to navigate to and an optional object with the following options:\n * \n * - resolve (*boolean*, default `true`): resolve the path against the current route\n * - replace (*boolean*, default `false`): replace the history entry\n * - scroll (*boolean*, default `true`): scroll to top after navigation\n * - state (*any*, default `undefined`): pass custom state to `location.state`\n * \n * **Note**: The state is serialized using the structured clone algorithm which does not support all object types.\n * \n * @example\n * ```js\n * const navigate = useNavigate();\n * \n * if (unauthorized) {\n *   navigate(\"/login\", { replace: true });\n * }\n * ```\n */\nconst useNavigate = () => useRouter().navigatorFactory();\n\n/**\n * Retrieves reactive `location` object useful for getting things like `pathname`.\n * \n * @example\n * ```js\n * const location = useLocation();\n * \n * const pathname = createMemo(() => parsePath(location.pathname));\n * ```\n */\nconst useLocation = () => useRouter().location;\n\n/**\n * Retrieves signal that indicates whether the route is currently in a *Transition*.\n * Useful for showing stale/pending state when the route resolution is *Suspended* during concurrent rendering.\n * \n * @example\n * ```js\n * const isRouting = useIsRouting();\n * \n * return (\n *   <div classList={{ \"grey-out\": isRouting() }}>\n *     <MyAwesomeContent />\n *   </div>\n * );\n * ```\n */\nconst useIsRouting = () => useRouter().isRouting;\n\n/**\n * usePreloadRoute returns a function that can be used to preload a route manual.\n * This is what happens automatically with link hovering and similar focus based behavior, but it is available here as an API.\n * \n * @example\n * ```js\n * const preload = usePreloadRoute();\n * \n * preload(`/users/settings`, { preloadData: true });\n * ```\n */\nconst usePreloadRoute = () => {\n  const pre = useRouter().preloadRoute;\n  return (url, options = {}) => pre(url instanceof URL ? url : new URL(url, mockBase), options.preloadData);\n};\n\n/**\n * `useMatch` takes an accessor that returns the path and creates a `Memo` that returns match information if the current path matches the provided path.\n * Useful for determining if a given path matches the current route.\n * \n * @example\n * ```js\n * const match = useMatch(() => props.href);\n * \n * return <div classList={{ active: Boolean(match()) }} />;\n * ```\n */\nconst useMatch = (path, matchFilters) => {\n  const location = useLocation();\n  const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\n  return createMemo(() => {\n    for (const matcher of matchers()) {\n      const match = matcher(location.pathname);\n      if (match) return match;\n    }\n  });\n};\n\n/**\n * `useCurrentMatches` returns all the matches for the current matched route.\n * Useful for getting all the route information.\n * \n * @example\n * ```js\n * const matches = useCurrentMatches();\n * \n * const breadcrumbs = createMemo(() => matches().map(m => m.route.info.breadcrumb))\n * ```\n */\nconst useCurrentMatches = () => useRouter().matches;\n\n/**\n * Retrieves a reactive, store-like object containing the current route path parameters as defined in the Route.\n * \n * @example\n * ```js\n * const params = useParams();\n * \n * // fetch user based on the id path parameter\n * const [user] = createResource(() => params.id, fetchUser);\n * ```\n */\nconst useParams = () => useRouter().params;\n\n/**\n * Retrieves a tuple containing a reactive object to read the current location's query parameters and a method to update them.\n * The object is a proxy so you must access properties to subscribe to reactive updates.\n * **Note** that values will be strings and property names will retain their casing.\n * \n * The setter method accepts an object whose entries will be merged into the current query string.\n * Values `''`, `undefined` and `null` will remove the key from the resulting query string.\n * Updates will behave just like a navigation and the setter accepts the same optional second parameter as `navigate` and auto-scrolling is disabled by default.\n * \n * @examples\n * ```js\n * const [searchParams, setSearchParams] = useSearchParams();\n * \n * return (\n *   <div>\n *     <span>Page: {searchParams.page}</span>\n *     <button\n *       onClick={() =>\n *         setSearchParams({ page: (parseInt(searchParams.page) || 0) + 1 })\n *       }\n *     >\n *       Next Page\n *     </button>\n *   </div>\n * );\n * ```\n */\nconst useSearchParams = () => {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const setSearchParams = (params, options) => {\n    const searchString = untrack(() => mergeSearchString(location.search, params) + location.hash);\n    navigate(searchString, {\n      scroll: false,\n      resolve: false,\n      ...options\n    });\n  };\n  return [location.query, setSearchParams];\n};\n\n/**\n * useBeforeLeave takes a function that will be called prior to leaving a route.\n * The function will be called with:\n * \n * - from (*Location*): current location (before change).\n * - to (*string | number*): path passed to `navigate`.\n * - options (*NavigateOptions*): options passed to navigate.\n * - preventDefault (*function*): call to block the route change.\n * - defaultPrevented (*readonly boolean*): `true` if any previously called leave handlers called `preventDefault`.\n * - retry (*function*, force?: boolean ): call to retry the same navigation, perhaps after confirming with the user. Pass `true` to skip running the leave handlers again (i.e. force navigate without confirming).\n * \n * @example\n * ```js\n * useBeforeLeave((e: BeforeLeaveEventArgs) => {\n *   if (form.isDirty && !e.defaultPrevented) {\n *     // preventDefault to block immediately and prompt user async\n *     e.preventDefault();\n *     setTimeout(() => {\n *       if (window.confirm(\"Discard unsaved changes - are you sure?\")) {\n *         // user wants to proceed anyway so retry with force=true\n *         e.retry(true);\n *       }\n *     }, 100);\n *   }\n * });\n * ```\n */\nconst useBeforeLeave = listener => {\n  const s = useRouter().beforeLeave.subscribe({\n    listener,\n    location: useLocation(),\n    navigate: useNavigate()\n  });\n  onCleanup(s);\n};\nfunction createRoutes(routeDef, base = \"\") {\n  const {\n    component,\n    preload,\n    load,\n    children,\n    info\n  } = routeDef;\n  const isLeaf = !children || Array.isArray(children) && !children.length;\n  const shared = {\n    key: routeDef,\n    component,\n    preload: preload || load,\n    info\n  };\n  return asArray(routeDef.path).reduce((acc, originalPath) => {\n    for (const expandedPath of expandOptionals(originalPath)) {\n      const path = joinPaths(base, expandedPath);\n      let pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n      pattern = pattern.split(\"/\").map(s => {\n        return s.startsWith(\":\") || s.startsWith(\"*\") ? s : encodeURIComponent(s);\n      }).join(\"/\");\n      acc.push({\n        ...shared,\n        originalPath,\n        pattern,\n        matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\n      });\n    }\n    return acc;\n  }, []);\n}\nfunction createBranch(routes, index = 0) {\n  return {\n    routes,\n    score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n    matcher(location) {\n      const matches = [];\n      for (let i = routes.length - 1; i >= 0; i--) {\n        const route = routes[i];\n        const match = route.matcher(location);\n        if (!match) {\n          return null;\n        }\n        matches.unshift({\n          ...match,\n          route\n        });\n      }\n      return matches;\n    }\n  };\n}\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction createBranches(routeDef, base = \"\", stack = [], branches = []) {\n  const routeDefs = asArray(routeDef);\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    if (def && typeof def === \"object\") {\n      if (!def.hasOwnProperty(\"path\")) def.path = \"\";\n      const routes = createRoutes(def, base);\n      for (const route of routes) {\n        stack.push(route);\n        const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\n        if (def.children && !isEmptyArray) {\n          createBranches(def.children, route.pattern, stack, branches);\n        } else {\n          const branch = createBranch([...stack], branches.length);\n          branches.push(branch);\n        }\n        stack.pop();\n      }\n    }\n  }\n\n  // Stack will be empty on final return\n  return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nfunction getRouteMatches(branches, location) {\n  for (let i = 0, len = branches.length; i < len; i++) {\n    const match = branches[i].matcher(location);\n    if (match) {\n      return match;\n    }\n  }\n  return [];\n}\nfunction createLocation(path, state, queryWrapper) {\n  const origin = new URL(mockBase);\n  const url = createMemo(prev => {\n    const path_ = path();\n    try {\n      return new URL(path_, origin);\n    } catch (err) {\n      console.error(`Invalid path ${path_}`);\n      return prev;\n    }\n  }, origin, {\n    equals: (a, b) => a.href === b.href\n  });\n  const pathname = createMemo(() => url().pathname);\n  const search = createMemo(() => url().search, true);\n  const hash = createMemo(() => url().hash);\n  const key = () => \"\";\n  const queryFn = on(search, () => extractSearchParams(url()));\n  return {\n    get pathname() {\n      return pathname();\n    },\n    get search() {\n      return search();\n    },\n    get hash() {\n      return hash();\n    },\n    get state() {\n      return state();\n    },\n    get key() {\n      return key();\n    },\n    query: queryWrapper ? queryWrapper(queryFn) : createMemoObject(queryFn)\n  };\n}\nlet intent;\nfunction getIntent() {\n  return intent;\n}\nlet inPreloadFn = false;\nfunction getInPreloadFn() {\n  return inPreloadFn;\n}\nfunction setInPreloadFn(value) {\n  inPreloadFn = value;\n}\nfunction createRouterContext(integration, branches, getContext, options = {}) {\n  const {\n    signal: [source, setSource],\n    utils = {}\n  } = integration;\n  const parsePath = utils.parsePath || (p => p);\n  const renderPath = utils.renderPath || (p => p);\n  const beforeLeave = utils.beforeLeave || createBeforeLeave();\n  const basePath = resolvePath(\"\", options.base || \"\");\n  if (basePath === undefined) {\n    throw new Error(`${basePath} is not a valid base path`);\n  } else if (basePath && !source().value) {\n    setSource({\n      value: basePath,\n      replace: true,\n      scroll: false\n    });\n  }\n  const [isRouting, setIsRouting] = createSignal(false);\n\n  // Keep track of last target, so that last call to transition wins\n  let lastTransitionTarget;\n\n  // Transition the location to a new value\n  const transition = (newIntent, newTarget) => {\n    if (newTarget.value === reference() && newTarget.state === state()) return;\n    if (lastTransitionTarget === undefined) setIsRouting(true);\n    intent = newIntent;\n    lastTransitionTarget = newTarget;\n    startTransition(() => {\n      if (lastTransitionTarget !== newTarget) return;\n      setReference(lastTransitionTarget.value);\n      setState(lastTransitionTarget.state);\n      resetErrorBoundaries();\n      if (!isServer) submissions[1](subs => subs.filter(s => s.pending));\n    }).finally(() => {\n      if (lastTransitionTarget !== newTarget) return;\n\n      // Batch, in order for isRouting and final source update to happen together\n      batch(() => {\n        intent = undefined;\n        if (newIntent === \"navigate\") navigateEnd(lastTransitionTarget);\n        setIsRouting(false);\n        lastTransitionTarget = undefined;\n      });\n    });\n  };\n  const [reference, setReference] = createSignal(source().value);\n  const [state, setState] = createSignal(source().state);\n  const location = createLocation(reference, state, utils.queryWrapper);\n  const referrers = [];\n  const submissions = createSignal(isServer ? initFromFlash() : []);\n  const matches = createMemo(() => {\n    if (typeof options.transformUrl === \"function\") {\n      return getRouteMatches(branches(), options.transformUrl(location.pathname));\n    }\n    return getRouteMatches(branches(), location.pathname);\n  });\n  const buildParams = () => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  };\n  const params = utils.paramsWrapper ? utils.paramsWrapper(buildParams, branches) : createMemoObject(buildParams);\n  const baseRoute = {\n    pattern: basePath,\n    path: () => basePath,\n    outlet: () => null,\n    resolvePath(to) {\n      return resolvePath(basePath, to);\n    }\n  };\n\n  // Create a native transition, when source updates\n  createRenderEffect(on(source, source => transition(\"native\", source), {\n    defer: true\n  }));\n  return {\n    base: baseRoute,\n    location,\n    params,\n    isRouting,\n    renderPath,\n    parsePath,\n    navigatorFactory,\n    matches,\n    beforeLeave,\n    preloadRoute,\n    singleFlight: options.singleFlight === undefined ? true : options.singleFlight,\n    submissions\n  };\n  function navigateFromRoute(route, to, options) {\n    // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n    untrack(() => {\n      if (typeof to === \"number\") {\n        if (!to) ; else if (utils.go) {\n          utils.go(to);\n        } else {\n          console.warn(\"Router integration does not support relative routing\");\n        }\n        return;\n      }\n      const queryOnly = !to || to[0] === \"?\";\n      const {\n        replace,\n        resolve,\n        scroll,\n        state: nextState\n      } = {\n        replace: false,\n        resolve: !queryOnly,\n        scroll: true,\n        ...options\n      };\n      const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(queryOnly && location.pathname || \"\", to);\n      if (resolvedTo === undefined) {\n        throw new Error(`Path '${to}' is not a routable path`);\n      } else if (referrers.length >= MAX_REDIRECTS) {\n        throw new Error(\"Too many redirects\");\n      }\n      const current = reference();\n      if (resolvedTo !== current || nextState !== state()) {\n        if (isServer) {\n          const e = getRequestEvent();\n          e && (e.response = {\n            status: 302,\n            headers: new Headers({\n              Location: resolvedTo\n            })\n          });\n          setSource({\n            value: resolvedTo,\n            replace,\n            scroll,\n            state: nextState\n          });\n        } else if (beforeLeave.confirm(resolvedTo, options)) {\n          referrers.push({\n            value: current,\n            replace,\n            scroll,\n            state: state()\n          });\n          transition(\"navigate\", {\n            value: resolvedTo,\n            state: nextState\n          });\n        }\n      }\n    });\n  }\n  function navigatorFactory(route) {\n    // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n    route = route || useContext(RouteContextObj) || baseRoute;\n    return (to, options) => navigateFromRoute(route, to, options);\n  }\n  function navigateEnd(next) {\n    const first = referrers[0];\n    if (first) {\n      setSource({\n        ...next,\n        replace: first.replace,\n        scroll: first.scroll\n      });\n      referrers.length = 0;\n    }\n  }\n  function preloadRoute(url, preloadData) {\n    const matches = getRouteMatches(branches(), url.pathname);\n    const prevIntent = intent;\n    intent = \"preload\";\n    for (let match in matches) {\n      const {\n        route,\n        params\n      } = matches[match];\n      route.component && route.component.preload && route.component.preload();\n      const {\n        preload\n      } = route;\n      inPreloadFn = true;\n      preloadData && preload && runWithOwner(getContext(), () => preload({\n        params,\n        location: {\n          pathname: url.pathname,\n          search: url.search,\n          hash: url.hash,\n          query: extractSearchParams(url),\n          state: null,\n          key: \"\"\n        },\n        intent: \"preload\"\n      }));\n      inPreloadFn = false;\n    }\n    intent = prevIntent;\n  }\n  function initFromFlash() {\n    const e = getRequestEvent();\n    return e && e.router && e.router.submission ? [e.router.submission] : [];\n  }\n}\nfunction createRouteContext(router, parent, outlet, match) {\n  const {\n    base,\n    location,\n    params\n  } = router;\n  const {\n    pattern,\n    component,\n    preload\n  } = match().route;\n  const path = createMemo(() => match().path);\n  component && component.preload && component.preload();\n  inPreloadFn = true;\n  const data = preload ? preload({\n    params,\n    location,\n    intent: intent || \"initial\"\n  }) : undefined;\n  inPreloadFn = false;\n  const route = {\n    parent,\n    pattern,\n    path,\n    outlet: () => component ? createComponent(component, {\n      params,\n      location,\n      data,\n      get children() {\n        return outlet();\n      }\n    }) : outlet(),\n    resolvePath(to) {\n      return resolvePath(base.path(), to, path());\n    }\n  };\n  return route;\n}\n\nconst createRouterComponent = router => props => {\n  const {\n    base\n  } = props;\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), props.base || \"\"));\n  let context;\n  const routerState = createRouterContext(router, branches, () => context, {\n    base,\n    singleFlight: props.singleFlight,\n    transformUrl: props.transformUrl\n  });\n  router.create && router.create(routerState);\n  return createComponent$1(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return createComponent$1(Root, {\n        routerState: routerState,\n        get root() {\n          return props.root;\n        },\n        get preload() {\n          return props.rootPreload || props.rootLoad;\n        },\n        get children() {\n          return [memo(() => (context = getOwner()) && null), createComponent$1(Routes, {\n            routerState: routerState,\n            get branches() {\n              return branches();\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nfunction Root(props) {\n  const location = props.routerState.location;\n  const params = props.routerState.params;\n  const data = createMemo(() => props.preload && untrack(() => {\n    setInPreloadFn(true);\n    props.preload({\n      params,\n      location,\n      intent: getIntent() || \"initial\"\n    });\n    setInPreloadFn(false);\n  }));\n  return createComponent$1(Show, {\n    get when() {\n      return props.root;\n    },\n    keyed: true,\n    get fallback() {\n      return props.children;\n    },\n    children: Root => createComponent$1(Root, {\n      params: params,\n      location: location,\n      get data() {\n        return data();\n      },\n      get children() {\n        return props.children;\n      }\n    })\n  });\n}\nfunction Routes(props) {\n  if (isServer) {\n    const e = getRequestEvent();\n    if (e && e.router && e.router.dataOnly) {\n      dataOnly(e, props.routerState, props.branches);\n      return;\n    }\n    e && ((e.router || (e.router = {})).matches || (e.router.matches = props.routerState.matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      path: route.originalPath,\n      pattern: route.pattern,\n      match: path,\n      params,\n      info: route.info\n    }))));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(props.routerState.matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(props.routerState, next[i - 1] || props.routerState.base, createOutlet(() => routeStates()[i + 1]), () => props.routerState.matches()[i]);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return createOutlet(() => routeStates() && root)();\n}\nconst createOutlet = child => {\n  return () => createComponent$1(Show, {\n    get when() {\n      return child();\n    },\n    keyed: true,\n    children: child => createComponent$1(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nconst Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\n\n// for data only mode with single flight mutations\nfunction dataOnly(event, routerState, branches) {\n  const url = new URL(event.request.url);\n  const prevMatches = getRouteMatches(branches, new URL(event.router.previousUrl || event.request.url).pathname);\n  const matches = getRouteMatches(branches, url.pathname);\n  for (let match = 0; match < matches.length; match++) {\n    if (!prevMatches[match] || matches[match].route !== prevMatches[match].route) event.router.dataOnly = true;\n    const {\n      route,\n      params\n    } = matches[match];\n    route.preload && route.preload({\n      params,\n      location: routerState.location,\n      intent: \"preload\"\n    });\n  }\n}\n\nfunction intercept([value, setValue], get, set) {\n  return [value, set ? v => setValue(set(v)) : setValue];\n}\nfunction createRouter(config) {\n  let ignore = false;\n  const wrap = value => typeof value === \"string\" ? {\n    value\n  } : value;\n  const signal = intercept(createSignal(wrap(config.get()), {\n    equals: (a, b) => a.value === b.value && a.state === b.state\n  }), undefined, next => {\n    !ignore && config.set(next);\n    if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = true;\n    return next;\n  });\n  config.init && onCleanup(config.init((value = config.get()) => {\n    ignore = true;\n    signal[1](wrap(value));\n    ignore = false;\n  }));\n  return createRouterComponent({\n    signal,\n    create: config.create,\n    utils: config.utils\n  });\n}\nfunction bindEvent(target, type, handler) {\n  target.addEventListener(type, handler);\n  return () => target.removeEventListener(type, handler);\n}\nfunction scrollToHash(hash, fallbackTop) {\n  const el = hash && document.getElementById(hash);\n  if (el) {\n    el.scrollIntoView();\n  } else if (fallbackTop) {\n    window.scrollTo(0, 0);\n  }\n}\n\nfunction getPath(url) {\n  const u = new URL(url);\n  return u.pathname + u.search;\n}\nfunction StaticRouter(props) {\n  let e;\n  const obj = {\n    value: props.url || (e = getRequestEvent()) && getPath(e.request.url) || \"\"\n  };\n  return createRouterComponent({\n    signal: [() => obj, next => Object.assign(obj, next)]\n  })(props);\n}\n\nconst LocationHeader = \"Location\";\nconst PRELOAD_TIMEOUT = 5000;\nconst CACHE_TIMEOUT = 180000;\nlet cacheMap = new Map();\n\n// cleanup forward/back cache\nif (!isServer) {\n  setInterval(() => {\n    const now = Date.now();\n    for (let [k, v] of cacheMap.entries()) {\n      if (!v[4].count && now - v[0] > CACHE_TIMEOUT) {\n        cacheMap.delete(k);\n      }\n    }\n  }, 300000);\n}\nfunction getCache() {\n  if (!isServer) return cacheMap;\n  const req = getRequestEvent();\n  if (!req) throw new Error(\"Cannot find cache context\");\n  return (req.router || (req.router = {})).cache || (req.router.cache = new Map());\n}\n\n/**\n * Revalidates the given cache entry/entries.\n */\nfunction revalidate(key, force = true) {\n  return startTransition(() => {\n    const now = Date.now();\n    cacheKeyOp(key, entry => {\n      force && (entry[0] = 0); //force cache miss\n      entry[4][1](now); // retrigger live signals\n    });\n  });\n}\nfunction cacheKeyOp(key, fn) {\n  key && !Array.isArray(key) && (key = [key]);\n  for (let k of cacheMap.keys()) {\n    if (key === undefined || matchKey(k, key)) fn(cacheMap.get(k));\n  }\n}\nfunction query(fn, name) {\n  // prioritize GET for server functions\n  if (fn.GET) fn = fn.GET;\n  const cachedFn = (...args) => {\n    const cache = getCache();\n    const intent = getIntent();\n    const inPreloadFn = getInPreloadFn();\n    const owner = getOwner();\n    const navigate = owner ? useNavigate() : undefined;\n    const now = Date.now();\n    const key = name + hashKey(args);\n    let cached = cache.get(key);\n    let tracking;\n    if (isServer) {\n      const e = getRequestEvent();\n      if (e) {\n        const dataOnly = (e.router || (e.router = {})).dataOnly;\n        if (dataOnly) {\n          const data = e && (e.router.data || (e.router.data = {}));\n          if (data && key in data) return data[key];\n          if (Array.isArray(dataOnly) && !matchKey(key, dataOnly)) {\n            data[key] = undefined;\n            return Promise.resolve();\n          }\n        }\n      }\n    }\n    if (getListener() && !isServer) {\n      tracking = true;\n      onCleanup(() => cached[4].count--);\n    }\n    if (cached && cached[0] && (isServer || intent === \"native\" || cached[4].count || Date.now() - cached[0] < PRELOAD_TIMEOUT)) {\n      if (tracking) {\n        cached[4].count++;\n        cached[4][0](); // track\n      }\n      if (cached[3] === \"preload\" && intent !== \"preload\") {\n        cached[0] = now;\n      }\n      let res = cached[1];\n      if (intent !== \"preload\") {\n        res = \"then\" in cached[1] ? cached[1].then(handleResponse(false), handleResponse(true)) : handleResponse(false)(cached[1]);\n        !isServer && intent === \"navigate\" && startTransition(() => cached[4][1](cached[0])); // update version\n      }\n      inPreloadFn && \"then\" in res && res.catch(() => {});\n      return res;\n    }\n    let res;\n    if (!isServer && sharedConfig.has && sharedConfig.has(key)) {\n      res = sharedConfig.load(key); // hydrating\n      // @ts-ignore at least until we add a delete method to sharedConfig\n      delete globalThis._$HY.r[key];\n    } else res = fn(...args);\n    if (cached) {\n      cached[0] = now;\n      cached[1] = res;\n      cached[3] = intent;\n      !isServer && intent === \"navigate\" && startTransition(() => cached[4][1](cached[0])); // update version\n    } else {\n      cache.set(key, cached = [now, res,, intent, createSignal(now)]);\n      cached[4].count = 0;\n    }\n    if (tracking) {\n      cached[4].count++;\n      cached[4][0](); // track\n    }\n    if (isServer) {\n      const e = getRequestEvent();\n      if (e && e.router.dataOnly) return e.router.data[key] = res;\n    }\n    if (intent !== \"preload\") {\n      res = \"then\" in res ? res.then(handleResponse(false), handleResponse(true)) : handleResponse(false)(res);\n    }\n    inPreloadFn && \"then\" in res && res.catch(() => {});\n    // serialize on server\n    if (isServer && sharedConfig.context && sharedConfig.context.async && !sharedConfig.context.noHydrate) {\n      const e = getRequestEvent();\n      (!e || !e.serverOnly) && sharedConfig.context.serialize(key, res);\n    }\n    return res;\n    function handleResponse(error) {\n      return async v => {\n        if (v instanceof Response) {\n          const url = v.headers.get(LocationHeader);\n          if (url !== null) {\n            // client + server relative redirect\n            if (navigate && url.startsWith(\"/\")) startTransition(() => {\n              navigate(url, {\n                replace: true\n              });\n            });else if (!isServer) window.location.href = url;else if (isServer) {\n              const e = getRequestEvent();\n              if (e) e.response = {\n                status: 302,\n                headers: new Headers({\n                  Location: url\n                })\n              };\n            }\n            return;\n          }\n          if (v.customBody) v = await v.customBody();\n        }\n        if (error) throw v;\n        cached[2] = v;\n        return v;\n      };\n    }\n  };\n  cachedFn.keyFor = (...args) => name + hashKey(args);\n  cachedFn.key = name;\n  return cachedFn;\n}\nquery.get = key => {\n  const cached = getCache().get(key);\n  return cached[2];\n};\nquery.set = (key, value) => {\n  const cache = getCache();\n  const now = Date.now();\n  let cached = cache.get(key);\n  if (cached) {\n    cached[0] = now;\n    cached[1] = Promise.resolve(value);\n    cached[2] = value;\n    cached[3] = \"preload\";\n  } else {\n    cache.set(key, cached = [now, Promise.resolve(value), value, \"preload\", createSignal(now)]);\n    cached[4].count = 0;\n  }\n};\nquery.delete = key => getCache().delete(key);\nquery.clear = () => getCache().clear();\n\n/** @deprecated use query instead */\nconst cache = query;\nfunction matchKey(key, keys) {\n  for (let k of keys) {\n    if (k && key.startsWith(k)) return true;\n  }\n  return false;\n}\n\n// Modified from the amazing Tanstack Query library (MIT)\n// https://github.com/TanStack/query/blob/main/packages/query-core/src/utils.ts#L168\nfunction hashKey(args) {\n  return JSON.stringify(args, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\nfunction isPlainObject(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (!(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype);\n}\n\nconst actions = /* #__PURE__ */new Map();\nfunction useSubmissions(fn, filter) {\n  const router = useRouter();\n  const subs = createMemo(() => router.submissions[0]().filter(s => s.url === fn.base && (!filter || filter(s.input))));\n  return new Proxy([], {\n    get(_, property) {\n      if (property === $TRACK) return subs();\n      if (property === \"pending\") return subs().some(sub => !sub.result);\n      return subs()[property];\n    },\n    has(_, property) {\n      return property in subs();\n    }\n  });\n}\nfunction useSubmission(fn, filter) {\n  const submissions = useSubmissions(fn, filter);\n  return new Proxy({}, {\n    get(_, property) {\n      if (submissions.length === 0 && property === \"clear\" || property === \"retry\") return () => {};\n      return submissions[submissions.length - 1]?.[property];\n    }\n  });\n}\nfunction useAction(action) {\n  const r = useRouter();\n  return (...args) => action.apply({\n    r\n  }, args);\n}\nfunction action(fn, options = {}) {\n  function mutate(...variables) {\n    const router = this.r;\n    const form = this.f;\n    const p = (router.singleFlight && fn.withOptions ? fn.withOptions({\n      headers: {\n        \"X-Single-Flight\": \"true\"\n      }\n    }) : fn)(...variables);\n    const [result, setResult] = createSignal();\n    let submission;\n    function handler(error) {\n      return async res => {\n        const result = await handleResponse(res, error, router.navigatorFactory());\n        let retry = null;\n        o.onComplete?.({\n          ...submission,\n          result: result?.data,\n          error: result?.error,\n          pending: false,\n          retry() {\n            return retry = submission.retry();\n          }\n        });\n        if (retry) return retry;\n        if (!result) return submission.clear();\n        setResult(result);\n        if (result.error && !form) throw result.error;\n        return result.data;\n      };\n    }\n    router.submissions[1](s => [...s, submission = {\n      input: variables,\n      url,\n      get result() {\n        return result()?.data;\n      },\n      get error() {\n        return result()?.error;\n      },\n      get pending() {\n        return !result();\n      },\n      clear() {\n        router.submissions[1](v => v.filter(i => i !== submission));\n      },\n      retry() {\n        setResult(undefined);\n        const p = fn(...variables);\n        return p.then(handler(), handler(true));\n      }\n    }]);\n    return p.then(handler(), handler(true));\n  }\n  const o = typeof options === \"string\" ? {\n    name: options\n  } : options;\n  const url = fn.url || o.name && `https://action/${o.name}` || (!isServer ? `https://action/${hashString(fn.toString())}` : \"\");\n  mutate.base = url;\n  return toAction(mutate, url);\n}\nfunction toAction(fn, url) {\n  fn.toString = () => {\n    if (!url) throw new Error(\"Client Actions need explicit names if server rendered\");\n    return url;\n  };\n  fn.with = function (...args) {\n    const newFn = function (...passedArgs) {\n      return fn.call(this, ...args, ...passedArgs);\n    };\n    newFn.base = fn.base;\n    const uri = new URL(url, mockBase);\n    uri.searchParams.set(\"args\", hashKey(args));\n    return toAction(newFn, (uri.origin === \"https://action\" ? uri.origin : \"\") + uri.pathname + uri.search);\n  };\n  fn.url = url;\n  if (!isServer) {\n    actions.set(url, fn);\n    getOwner() && onCleanup(() => actions.delete(url));\n  }\n  return fn;\n}\nconst hashString = s => s.split(\"\").reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0);\nasync function handleResponse(response, error, navigate) {\n  let data;\n  let custom;\n  let keys;\n  let flightKeys;\n  if (response instanceof Response) {\n    if (response.headers.has(\"X-Revalidate\")) keys = response.headers.get(\"X-Revalidate\").split(\",\");\n    if (response.customBody) {\n      data = custom = await response.customBody();\n      if (response.headers.has(\"X-Single-Flight\")) {\n        data = data._$value;\n        delete custom._$value;\n        flightKeys = Object.keys(custom);\n      }\n    }\n    if (response.headers.has(\"Location\")) {\n      const locationUrl = response.headers.get(\"Location\") || \"/\";\n      if (locationUrl.startsWith(\"http\")) {\n        window.location.href = locationUrl;\n      } else {\n        navigate(locationUrl);\n      }\n    }\n  } else if (error) return {\n    error: response\n  };else data = response;\n  // invalidate\n  cacheKeyOp(keys, entry => entry[0] = 0);\n  // set cache\n  flightKeys && flightKeys.forEach(k => query.set(k, custom[k]));\n  // trigger revalidation\n  await revalidate(keys, false);\n  return data != null ? {\n    data\n  } : undefined;\n}\n\nfunction setupNativeEvents(preload = true, explicitLinks = false, actionBase = \"/_server\", transformUrl) {\n  return router => {\n    const basePath = router.base.path();\n    const navigateFromRoute = router.navigatorFactory(router.base);\n    let preloadTimeout;\n    let lastElement;\n    function isSvg(el) {\n      return el.namespaceURI === \"http://www.w3.org/2000/svg\";\n    }\n    function handleAnchor(evt) {\n      if (evt.defaultPrevented || evt.button !== 0 || evt.metaKey || evt.altKey || evt.ctrlKey || evt.shiftKey) return;\n      const a = evt.composedPath().find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\n      if (!a || explicitLinks && !a.hasAttribute(\"link\")) return;\n      const svg = isSvg(a);\n      const href = svg ? a.href.baseVal : a.href;\n      const target = svg ? a.target.baseVal : a.target;\n      if (target || !href && !a.hasAttribute(\"state\")) return;\n      const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\n      if (a.hasAttribute(\"download\") || rel && rel.includes(\"external\")) return;\n      const url = svg ? new URL(href, document.baseURI) : new URL(href);\n      if (url.origin !== window.location.origin || basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase())) return;\n      return [a, url];\n    }\n    function handleAnchorClick(evt) {\n      const res = handleAnchor(evt);\n      if (!res) return;\n      const [a, url] = res;\n      const to = router.parsePath(url.pathname + url.search + url.hash);\n      const state = a.getAttribute(\"state\");\n      evt.preventDefault();\n      navigateFromRoute(to, {\n        resolve: false,\n        replace: a.hasAttribute(\"replace\"),\n        scroll: !a.hasAttribute(\"noscroll\"),\n        state: state ? JSON.parse(state) : undefined\n      });\n    }\n    function handleAnchorPreload(evt) {\n      const res = handleAnchor(evt);\n      if (!res) return;\n      const [a, url] = res;\n      transformUrl && (url.pathname = transformUrl(url.pathname));\n      router.preloadRoute(url, a.getAttribute(\"preload\") !== \"false\");\n    }\n    function handleAnchorMove(evt) {\n      clearTimeout(preloadTimeout);\n      const res = handleAnchor(evt);\n      if (!res) return lastElement = null;\n      const [a, url] = res;\n      if (lastElement === a) return;\n      transformUrl && (url.pathname = transformUrl(url.pathname));\n      preloadTimeout = setTimeout(() => {\n        router.preloadRoute(url, a.getAttribute(\"preload\") !== \"false\");\n        lastElement = a;\n      }, 20);\n    }\n    function handleFormSubmit(evt) {\n      if (evt.defaultPrevented) return;\n      let actionRef = evt.submitter && evt.submitter.hasAttribute(\"formaction\") ? evt.submitter.getAttribute(\"formaction\") : evt.target.getAttribute(\"action\");\n      if (!actionRef) return;\n      if (!actionRef.startsWith(\"https://action/\")) {\n        // normalize server actions\n        const url = new URL(actionRef, mockBase);\n        actionRef = router.parsePath(url.pathname + url.search);\n        if (!actionRef.startsWith(actionBase)) return;\n      }\n      if (evt.target.method.toUpperCase() !== \"POST\") throw new Error(\"Only POST forms are supported for Actions\");\n      const handler = actions.get(actionRef);\n      if (handler) {\n        evt.preventDefault();\n        const data = new FormData(evt.target, evt.submitter);\n        handler.call({\n          r: router,\n          f: evt.target\n        }, evt.target.enctype === \"multipart/form-data\" ? data : new URLSearchParams(data));\n      }\n    }\n\n    // ensure delegated event run first\n    delegateEvents([\"click\", \"submit\"]);\n    document.addEventListener(\"click\", handleAnchorClick);\n    if (preload) {\n      document.addEventListener(\"mousemove\", handleAnchorMove, {\n        passive: true\n      });\n      document.addEventListener(\"focusin\", handleAnchorPreload, {\n        passive: true\n      });\n      document.addEventListener(\"touchstart\", handleAnchorPreload, {\n        passive: true\n      });\n    }\n    document.addEventListener(\"submit\", handleFormSubmit);\n    onCleanup(() => {\n      document.removeEventListener(\"click\", handleAnchorClick);\n      if (preload) {\n        document.removeEventListener(\"mousemove\", handleAnchorMove);\n        document.removeEventListener(\"focusin\", handleAnchorPreload);\n        document.removeEventListener(\"touchstart\", handleAnchorPreload);\n      }\n      document.removeEventListener(\"submit\", handleFormSubmit);\n    });\n  };\n}\n\nfunction Router(props) {\n  if (isServer) return StaticRouter(props);\n  const getSource = () => {\n    const url = window.location.pathname.replace(/^\\/+/, \"/\") + window.location.search;\n    const state = window.history.state && window.history.state._depth && Object.keys(window.history.state).length === 1 ? undefined : window.history.state;\n    return {\n      value: url + window.location.hash,\n      state\n    };\n  };\n  const beforeLeave = createBeforeLeave();\n  return createRouter({\n    get: getSource,\n    set({\n      value,\n      replace,\n      scroll,\n      state\n    }) {\n      if (replace) {\n        window.history.replaceState(keepDepth(state), \"\", value);\n      } else {\n        window.history.pushState(state, \"\", value);\n      }\n      scrollToHash(decodeURIComponent(window.location.hash.slice(1)), scroll);\n      saveCurrentDepth();\n    },\n    init: notify => bindEvent(window, \"popstate\", notifyIfNotBlocked(notify, delta => {\n      if (delta && delta < 0) {\n        return !beforeLeave.confirm(delta);\n      } else {\n        const s = getSource();\n        return !beforeLeave.confirm(s.value, {\n          state: s.state\n        });\n      }\n    })),\n    create: setupNativeEvents(props.preload, props.explicitLinks, props.actionBase, props.transformUrl),\n    utils: {\n      go: delta => window.history.go(delta),\n      beforeLeave\n    }\n  })(props);\n}\n\nfunction hashParser(str) {\n  const to = str.replace(/^.*?#/, \"\");\n  // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\n  // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\n  // to the current path so we can handle these in-page anchors correctly.\n  if (!to.startsWith(\"/\")) {\n    const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\n    return `${path}#${to}`;\n  }\n  return to;\n}\nfunction HashRouter(props) {\n  const getSource = () => window.location.hash.slice(1);\n  const beforeLeave = createBeforeLeave();\n  return createRouter({\n    get: getSource,\n    set({\n      value,\n      replace,\n      scroll,\n      state\n    }) {\n      if (replace) {\n        window.history.replaceState(keepDepth(state), \"\", \"#\" + value);\n      } else {\n        window.history.pushState(state, \"\", \"#\" + value);\n      }\n      const hashIndex = value.indexOf(\"#\");\n      const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\n      scrollToHash(hash, scroll);\n      saveCurrentDepth();\n    },\n    init: notify => bindEvent(window, \"hashchange\", notifyIfNotBlocked(notify, delta => !beforeLeave.confirm(delta && delta < 0 ? delta : getSource()))),\n    create: setupNativeEvents(props.preload, props.explicitLinks, props.actionBase),\n    utils: {\n      go: delta => window.history.go(delta),\n      renderPath: path => `#${path}`,\n      parsePath: hashParser,\n      beforeLeave\n    }\n  })(props);\n}\n\nfunction createMemoryHistory() {\n  const entries = [\"/\"];\n  let index = 0;\n  const listeners = [];\n  const go = n => {\n    // https://github.com/remix-run/react-router/blob/682810ca929d0e3c64a76f8d6e465196b7a2ac58/packages/router/history.ts#L245\n    index = Math.max(0, Math.min(index + n, entries.length - 1));\n    const value = entries[index];\n    listeners.forEach(listener => listener(value));\n  };\n  return {\n    get: () => entries[index],\n    set: ({\n      value,\n      scroll,\n      replace\n    }) => {\n      if (replace) {\n        entries[index] = value;\n      } else {\n        entries.splice(index + 1, entries.length - index, value);\n        index++;\n      }\n      listeners.forEach(listener => listener(value));\n      setTimeout(() => {\n        if (scroll) {\n          scrollToHash(value.split(\"#\")[1] || \"\", true);\n        }\n      }, 0);\n    },\n    back: () => {\n      go(-1);\n    },\n    forward: () => {\n      go(1);\n    },\n    go,\n    listen: listener => {\n      listeners.push(listener);\n      return () => {\n        const index = listeners.indexOf(listener);\n        listeners.splice(index, 1);\n      };\n    }\n  };\n}\nfunction MemoryRouter(props) {\n  const memoryHistory = props.history || createMemoryHistory();\n  return createRouter({\n    get: memoryHistory.get,\n    set: memoryHistory.set,\n    init: memoryHistory.listen,\n    create: setupNativeEvents(props.preload, props.explicitLinks, props.actionBase),\n    utils: {\n      go: memoryHistory.go\n    }\n  })(props);\n}\n\nvar _tmpl$ = /*#__PURE__*/template(`<a>`);\nfunction A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return [false, false];\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = decodeURI(normalizePath(location.pathname).toLowerCase());\n    return [props.end ? path === loc : loc.startsWith(path + \"/\") || loc === path, path === loc];\n  });\n  return (() => {\n    var _el$ = _tmpl$();\n    spread(_el$, mergeProps$1(rest, {\n      get href() {\n        return href() || props.href;\n      },\n      get state() {\n        return JSON.stringify(props.state);\n      },\n      get classList() {\n        return {\n          ...(props.class && {\n            [props.class]: true\n          }),\n          [props.inactiveClass]: !isActive()[0],\n          [props.activeClass]: isActive()[0],\n          ...rest.classList\n        };\n      },\n      \"link\": \"\",\n      get [\"aria-current\"]() {\n        return isActive()[1] ? \"page\" : undefined;\n      }\n    }), false, false);\n    return _el$;\n  })();\n}\nfunction Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}\n\n/**\n * This is mock of the eventual Solid 2.0 primitive. It is not fully featured.\n */\n\n/**\n * As `createAsync` and `createAsyncStore` are wrappers for `createResource`,\n * this type allows to support `latest` field for these primitives.\n * It will be removed in the future.\n */\n\nfunction createAsync(fn, options) {\n  let resource;\n  let prev = () => !resource || resource.state === \"unresolved\" ? undefined : resource.latest;\n  [resource] = createResource(() => subFetch(fn, untrack(prev)), v => v, options);\n  const resultAccessor = () => resource();\n  Object.defineProperty(resultAccessor, 'latest', {\n    get() {\n      return resource.latest;\n    }\n  });\n  return resultAccessor;\n}\nfunction createAsyncStore(fn, options = {}) {\n  let resource;\n  let prev = () => !resource || resource.state === \"unresolved\" ? undefined : unwrap(resource.latest);\n  [resource] = createResource(() => subFetch(fn, untrack(prev)), v => v, {\n    ...options,\n    storage: init => createDeepSignal(init, options.reconcile)\n  });\n  const resultAccessor = () => resource();\n  Object.defineProperty(resultAccessor, 'latest', {\n    get() {\n      return resource.latest;\n    }\n  });\n  return resultAccessor;\n}\nfunction createDeepSignal(value, options) {\n  const [store, setStore] = createStore({\n    value: structuredClone(value)\n  });\n  return [() => store.value, v => {\n    typeof v === \"function\" && (v = v());\n    setStore(\"value\", reconcile(structuredClone(v), options));\n    return store.value;\n  }];\n}\n\n// mock promise while hydrating to prevent fetching\nclass MockPromise {\n  static all() {\n    return new MockPromise();\n  }\n  static allSettled() {\n    return new MockPromise();\n  }\n  static any() {\n    return new MockPromise();\n  }\n  static race() {\n    return new MockPromise();\n  }\n  static reject() {\n    return new MockPromise();\n  }\n  static resolve() {\n    return new MockPromise();\n  }\n  catch() {\n    return new MockPromise();\n  }\n  then() {\n    return new MockPromise();\n  }\n  finally() {\n    return new MockPromise();\n  }\n}\nfunction subFetch(fn, prev) {\n  if (isServer || !sharedConfig.context) return fn(prev);\n  const ogFetch = fetch;\n  const ogPromise = Promise;\n  try {\n    window.fetch = () => new MockPromise();\n    Promise = MockPromise;\n    return fn(prev);\n  } finally {\n    window.fetch = ogFetch;\n    Promise = ogPromise;\n  }\n}\n\nfunction redirect(url, init = 302) {\n  let responseInit;\n  let revalidate;\n  if (typeof init === \"number\") {\n    responseInit = {\n      status: init\n    };\n  } else {\n    ({\n      revalidate,\n      ...responseInit\n    } = init);\n    if (typeof responseInit.status === \"undefined\") {\n      responseInit.status = 302;\n    }\n  }\n  const headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  revalidate !== undefined && headers.set(\"X-Revalidate\", revalidate.toString());\n  const response = new Response(null, {\n    ...responseInit,\n    headers: headers\n  });\n  return response;\n}\nfunction reload(init = {}) {\n  const {\n    revalidate,\n    ...responseInit\n  } = init;\n  const headers = new Headers(responseInit.headers);\n  revalidate !== undefined && headers.set(\"X-Revalidate\", revalidate.toString());\n  return new Response(null, {\n    ...responseInit,\n    headers\n  });\n}\nfunction json(data, init = {}) {\n  const {\n    revalidate,\n    ...responseInit\n  } = init;\n  const headers = new Headers(responseInit.headers);\n  revalidate !== undefined && headers.set(\"X-Revalidate\", revalidate.toString());\n  headers.set(\"Content-Type\", \"application/json\");\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n  response.customBody = () => data;\n  return response;\n}\n\nexport { A, HashRouter, MemoryRouter, Navigate, Route, Router, StaticRouter, mergeSearchString as _mergeSearchString, action, cache, createAsync, createAsyncStore, createBeforeLeave, createMemoryHistory, createRouter, json, keepDepth, notifyIfNotBlocked, query, redirect, reload, revalidate, saveCurrentDepth, useAction, useBeforeLeave, useCurrentMatches, useHref, useIsRouting, useLocation, useMatch, useNavigate, useParams, usePreloadRoute, useResolvedPath, useSearchParams, useSubmission, useSubmissions };\n","export {\n  createComponent,\n  createContext,\n  createSignal,\n  onCleanup,\n  useContext,\n} from 'solid-js';\n\nexport {\n  render,\n  memo,\n} from 'solid-js/web';\n\nimport html from 'solid-js/html';\nexport default html;\n\nexport {\n  Route,\n  Router,\n  useParams,\n  Navigate,\n} from '@solidjs/router';\n"],"x_google_ignoreList":[0,1,2,3],"mappings":"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CX,GAAG;EACH,OAAO;CACR;CACD,UAAU;EACR,GAAG;EACH,OAAO;EACP,UAAU;CACX;AACF,EAAC;AACF,SAAS,aAAa,MAAMC,WAAS;CACnC,MAAM,IAAI,YAAY;AACtB,eAAc,MAAM,WAAY,EAAEA,aAAW,EAAE,gBAAoB;AACpE;AACD,MAAM,kCAAgC,IAAI,IAAI;CAC5C;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACD;AACD,MAAM,8BAA4B,IAAI,IAAI;CACxC;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACD;AACD,MAAM,eAAe;CACnB,OAAO;CACP,KAAK;AACN;AA2RD,SAAS,gBAAgB,YAAY,GAAG,GAAG;KACrC,UAAU,EAAE;KACd,OAAO,EAAE;KACT,OAAO;KACP,SAAS;KACT,SAAS;KACT,QAAQ,EAAE,OAAO,GAAG;KACpB,MAAM;AACR,QAAO,SAAS,QAAQ,SAAS,MAAM;AACrC,MAAI,EAAE,YAAY,EAAE,SAAS;AAC3B;AACA;AACA;EACD;AACD,SAAO,EAAE,OAAO,OAAO,EAAE,OAAO,IAAI;AAClC;AACA;EACD;AACD,MAAI,SAAS,QAAQ;GACnB,MAAM,OAAO,OAAO,UAAW,SAAS,EAAE,SAAS,GAAG,cAAc,EAAE,OAAO,UAAW;AACxF,UAAO,SAAS,KAAM,YAAW,aAAa,EAAE,WAAW,KAAK;EACjE,WAAU,SAAS,OAClB,Q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"}